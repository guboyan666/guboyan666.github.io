<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-管道与重定向-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/08/%E7%AE%A1%E9%81%93%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91-1/" class="article-date">
  <time class="dt-published" datetime="2024-09-08T07:30:29.000Z" itemprop="datePublished">2024-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/08/%E7%AE%A1%E9%81%93%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91-1/">管道与重定向</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/08/%E7%AE%A1%E9%81%93%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91-1/" data-id="cm0t98zt80000w0vy2wt5fdxs" data-title="管道与重定向" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-面试题谷/面试题谷" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/07/%E9%9D%A2%E8%AF%95%E9%A2%98%E8%B0%B7/%E9%9D%A2%E8%AF%95%E9%A2%98%E8%B0%B7/" class="article-date">
  <time class="dt-published" datetime="2024-09-07T13:50:00.000Z" itemprop="datePublished">2024-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/07/%E9%9D%A2%E8%AF%95%E9%A2%98%E8%B0%B7/%E9%9D%A2%E8%AF%95%E9%A2%98%E8%B0%B7/">面试题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>面试题</strong></p>
<h4 id="0、桥接网络和NAT网络区别？"><a href="#0、桥接网络和NAT网络区别？" class="headerlink" title="0、桥接网络和NAT网络区别？"></a>0、桥接网络和NAT网络区别？</h4><p>桥接：Bridged Networking–桥接网络（模式）：手动配置IP、子网掩码、网关，地址需要和宿主机同一网段，相当于局域网内新建了一台主机。可进可出。</p>
<p> NAT：Network Address Translation–网络地址转换（模式）：是一种常见的网络技术，用于将私有网络中的内部 IP 地址转换为公共 IP 地址，以实现与外部网络的通信。：扎根于宿主机，不能和局域网内其它真实的主机进行通信。只能出不能进。</p>
<h4 id="1、Linux操作系统你都熟悉哪一些？"><a href="#1、Linux操作系统你都熟悉哪一些？" class="headerlink" title="1、Linux操作系统你都熟悉哪一些？"></a><strong>1、Linux操作系统你都熟悉哪一些？</strong></h4><p>red-hat,Centos，Debian,.ubuntu,opensuse,华为欧拉</p>
<h4 id="2、Centos和Ubuntu有什么区别？"><a href="#2、Centos和Ubuntu有什么区别？" class="headerlink" title="2、Centos和Ubuntu有什么区别？"></a><strong>2、Centos和Ubuntu有什么区别？</strong></h4><p>centos基于 Red Hat Enterprise Linux (RHEL)，旨在提供一个企业级的稳定环境，通常用于服务器和企业应用。ubuntu基于 Debian，面向桌面和服务器市场。</p>
<p>ubuntu使用.deb和.snap的软件包，centos使用.rpm和flatpak软件包。ubuntu使用apt来更新，Centos使用yum。</p>
<p>centos更新频率不高，更稳定，服务器部署多，文档丰富，对运维友好。</p>
<p>Ubuntu更新频率高，功能更新，图形桌面支持更好，对开发和个人用更友好。</p>
<h4 id="3、centos6与centos7有何不同？"><a href="#3、centos6与centos7有何不同？" class="headerlink" title="3、centos6与centos7有何不同？"></a>3、centos6与centos7有何不同？</h4><ol>
<li><p>系统架构<br> CentOS 6: 基于 Red Hat Enterprise Linux (RHEL) 6。<br> CentOS 7: 基于 Red Hat Enterprise Linux (RHEL) 7。</p>
</li>
<li><p>初始化系统<br> CentOS 6: 使用 SysVinit 作为初始化系统。SysVinit 是传统的初始化系统，启动过程比较复杂。<br> CentOS 7: 采用了 systemd 作为初始化系统。systemd 提供了更高效的服务管理和启动过程，并支持并行服务启动，更加现代化。</p>
</li>
<li><p>默认文件系统<br> CentOS 6: 默认使用 ext4 文件系统。<br> CentOS 7: 默认使用 XFS 文件系统。XFS 提供了更好的性能和扩展性，特别是对于大文件和大文件系统。</p>
</li>
<li><p>网络管理<br> CentOS 6: 使用 network 服务和传统的配置文件 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F; 进行网络管理。<br> CentOS 7: 引入了 NetworkManager 和新的配置工具 nmcli 和 nmtui，使得网络管理更加灵活和现代化。</p>
</li>
<li><p>软件包管理<br> CentOS 6: 使用 yum 作为包管理工具。<br> CentOS 7: 也使用 yum，但改进了对依赖关系的处理。CentOS 7 还引入了新的软件包版本和更多的最新软件。</p>
</li>
<li><p>内核版本<br> CentOS 6: 基于 Linux 内核 2.6.x。<br> CentOS 7: 基于 Linux 内核 3.10.x，提供了更多的硬件支持和性能改进。</p>
</li>
<li><p>图形用户界面<br> CentOS 6: 默认使用 GNOME 2 桌面环境。<br> CentOS 7: 默认使用 GNOME 3 桌面环境，提供了更现代化的用户体验和界面。</p>
</li>
<li><p>服务管理<br>CentOS 6: 服务管理主要通过传统的 service 命令。<br>CentOS 7: 服务管理通过 systemctl 命令，提供了更强大的服务管理功能。</p>
</li>
<li><p>系统要求<br>CentOS 6: 系统要求相对较低，适用于旧硬件。<br>CentOS 7: 对硬件的要求较高，特别是在内存和处理器方面。</p>
<p>CentOS 7 引入了许多现代化的技术和功能，相比 CentOS 6 提供了更好的性能、安全性和可管理性。如果你的系统需要长期支持和维护，建议使用 CentOS 7 或更高版本，因为 CentOS 6 的支持已经结束，意味着不会再提供安全更新或修复。</p>
<h4 id="4-OSI七层模型及每层常见协议或设备"><a href="#4-OSI七层模型及每层常见协议或设备" class="headerlink" title="4.OSI七层模型及每层常见协议或设备"></a>4.OSI七层模型及每层常见协议或设备</h4><p>物理层：透明传输比特流<br>网线，中继器，集线器</p>
<p>数据链路层：在两个相邻节点间传输以帧为单位的数据。<br>MAC地址，网卡，网桥，交换机</p>
<p>网络层：IP报传输和路由选择<br>IP，icmp，arp路由器</p>
<p>传输层：负责主机间两个进程的通信<br>TCP，UDP，端口，进程，</p>
<p>会话层：管理会话和数据同步<br>验证用户登录，断点续传</p>
<p>表示层：负责数据格式化、转换和加密<br>加密和解密</p>
<p>应用层：直接为用户的应用进程提供服务。<br>telnet，ftp，http，https，DNS，smtp，pop3</p>
<h4 id="5、Tcp与Udp的区别？"><a href="#5、Tcp与Udp的区别？" class="headerlink" title="5、Tcp与Udp的区别？"></a>5、Tcp与Udp的区别？</h4><p>tcp：面向连接，面向字节流，提供可靠的数据传输服务，每条Tcp连接只能是点对点的。支持全双工通信。</p>
<p>邮件发送，网页浏览，远程登录</p>
<p>udp：无连接，面向报文，支持一对一，一对多，多对一，多对多的交互通信，不保证数据的可靠传输。尽最大努力交付。</p>
<p>qq聊天，实时应用，在线游戏。</p>
<h4 id="6、三次握手"><a href="#6、三次握手" class="headerlink" title="6、三次握手"></a>6、三次握手</h4><p><img src="C:\Users\23568\AppData\Roaming\Typora\typora-user-images\image-20240831172050541.png" alt="image-20240831172050541"></p>
<p>客户端应用进程主动打开，并向服务器端发送建立连接的请求</p>
<p>服务器端应用进程被动打开，若同意客户端的请求，则发回确认报文段。</p>
<p>客户端收到确认报文段后，通知其上层应用进程连接已经建立，并发回确认报文段，服务器收到确认报文段后，也通知其上层应用进程连接已经建立。</p>
<h4 id="7、四次挥手"><a href="#7、四次挥手" class="headerlink" title="7、四次挥手"></a>7、四次挥手</h4><p><img src="C:\Users\23568\AppData\Roaming\Typora\typora-user-images\image-20240831172024866.png" alt="image-20240831172024866"></p>
<p>客户端发送连接释放报文段，停止发送数据，主动关闭tcp连接。</p>
<p>服务器端发回一个确认报文段，客户端到服务器端方向的连接就释放了。</p>
<p>服务器端发完数据，就发送释放连接的报文段，主动关闭TCP连接，</p>
<p>客户端回送一个确认报文段，再等到时间计时器设置的2MSL后，连接彻底关闭。</p>
<h4 id="5-DNS解析流程"><a href="#5-DNS解析流程" class="headerlink" title="5.DNS解析流程"></a>5.DNS解析流程</h4><p>检查浏览器缓存和系统缓存</p>
<p>本地DNS服务查询</p>
<p>DNS根服务器查询</p>
<p>顶级DNS服务器查询</p>
<p>权威DNS服务器查询</p>
<p>返回结果，浏览器显示结果内容。</p>
<p>DNS将域名解析为IP地址</p>
<p>ARP：将本机默认网关ip地址映射为物理MAC地址。</p>
</li>
</ol>
<h4 id="2、Linux中的文件类型有哪些？"><a href="#2、Linux中的文件类型有哪些？" class="headerlink" title="2、Linux中的文件类型有哪些？"></a>2、Linux中的文件类型有哪些？</h4><p>-:普通文件，d:目录文件，l:链接文件，p:管道文件，s:套接字文件，b:块设备文件</p>
<h4 id="3-Linux中根下都有哪些目录？"><a href="#3-Linux中根下都有哪些目录？" class="headerlink" title="3.Linux中根下都有哪些目录？"></a>3.Linux中根下都有哪些目录？</h4><p>bin&#x2F;sbin：存放命令文件</p>
<p>etc：存放配置文件</p>
<p>dev：设备文件</p>
<p>home：存放用户家目录</p>
<p>lib：库文件</p>
<p>mnt：临时挂载文件</p>
<p>proc：虚拟文件系统，查看进程信息</p>
<p>tmp：临时文件</p>
<p>var：存放日志、缓存、邮件等</p>
<p>root：管理员用户家目录</p>
<p>usr：用户程序资源，命令、库文件、头文件和共享数据等</p>
<p>boot：存放系统启动相关的文件</p>
<p>&#x2F;usr&#x2F;local ：用户级的软件目录，用来存放用户安装编译的软件，用户自己编译安装的软件也默认存放在这里。</p>
<p><code>/usr/src</code>：系统级的源码目录。<br><code>/usr/local/src</code>：用户级的源码目录。</p>
<h4 id="3、Linux都可以做什么优化？"><a href="#3、Linux都可以做什么优化？" class="headerlink" title="3、Linux都可以做什么优化？"></a><strong>3、Linux都可以做什么优化？</strong></h4><p>​     提示：性能方面、安全方面</p>
<ol>
<li><p><strong>更新和补丁管理</strong>：</p>
<ul>
<li>及时更新系统和软件包，确保应用安全修补程序，以修复已知漏洞和安全问题。</li>
</ul>
</li>
<li><p><strong>强化账户和访问控制</strong>：</p>
<ul>
<li>管理用户和组账户，确保只有授权的用户能够访问系统资源。</li>
<li>使用最小权限原则，给予用户最小必需的权限来完成工作。</li>
</ul>
</li>
<li><p><strong>防火墙设置</strong>：</p>
<ul>
<li>配置和管理防火墙规则，限制进入和离开系统的流量，阻止未授权的访问和攻击尝试。</li>
</ul>
</li>
<li><p><strong>加固服务和进程</strong>：</p>
<ul>
<li>关闭不必要的服务和端口，减少系统暴露的攻击面。</li>
<li>使用安全选项和配置参数，如限制服务的运行权限、启用访问日志记录等。</li>
</ul>
</li>
<li><p><strong>安全审计和监控</strong>：</p>
<ul>
<li>配置和启用安全审计功能，监控系统和应用的活动，检测潜在的安全事件和异常行为。</li>
<li>使用日志管理工具来集中管理和分析系统日志，及时发现异常和安全事件。</li>
</ul>
</li>
<li><p><strong>文件系统和权限控制</strong>：</p>
<ul>
<li>使用文件系统加密（如LUKS）来保护重要数据和配置文件。</li>
<li>设置文件和目录的权限，确保敏感数据和系统文件只有合适的用户或进程能够访问和修改。</li>
</ul>
</li>
<li><p><strong>加密和安全传输</strong>：</p>
<ul>
<li>使用SSL&#x2F;TLS协议保护网络通信，特别是对于敏感数据的传输。</li>
<li>加密存储设备和备份文件，以防止数据泄露和未授权访问。</li>
</ul>
</li>
<li><p><strong>应急响应计划和备份</strong>：</p>
<ul>
<li><p>制定应急响应计划，包括处理安全事件和恢复系统的步骤。</p>
</li>
<li><p>定期备份重要数据，并确保备份的安全存储和可靠性，以便在需要时快速恢复系统。</p>
<h4 id="linux系统调优"><a href="#linux系统调优" class="headerlink" title="linux系统调优"></a><strong>linux系统调优</strong></h4><ol>
<li><strong>文件系统调优</strong>：<ul>
<li><strong>选择合适的文件系统</strong>：根据不同的应用需求选择适合的文件系统，如ext4、XFS等。</li>
<li><strong>调整文件系统参数</strong>：可以通过调整参数如inode数量、日志写入方式等来优化文件系统的性能。</li>
</ul>
</li>
<li><strong>内核参数调优</strong>：<ul>
<li><strong>sysctl设置</strong>：通过修改 <code>/etc/sysctl.conf</code> 文件中的参数来优化内核行为，如调整网络参数、文件系统参数、内存管理参数等。</li>
<li><strong>调整调度器</strong>：Linux内核提供了多种进程调度器（如CFS），可以根据工作负载选择合适的调度策略。</li>
</ul>
</li>
<li><strong>内存管理</strong>：<ul>
<li><strong>使用高效的内存分配器</strong>：如jemalloc、tcmalloc等，用于优化内存分配性能。</li>
<li><strong>调整虚拟内存参数</strong>：如通过sysctl调整swap的使用策略，或者调整vm.overcommit_memory参数来优化内存使用。</li>
</ul>
</li>
<li><strong>网络优化</strong>：<ul>
<li><strong>调整网络堆栈参数</strong>：如增大TCP缓冲区、优化网络延迟等，可以通过sysctl进行调整。</li>
<li><strong>使用高效的网络设备驱动</strong>：选择支持高性能的网络设备驱动程序，以提升网络吞吐量和稳定性。</li>
</ul>
</li>
<li><strong>硬件性能调优</strong>：<ul>
<li><strong>CPU调优</strong>：通过调整CPU调度策略、启用CPU频率调节器等来优化CPU性能和功耗。</li>
<li><strong>存储设备优化</strong>：如SSD上使用trim命令、RAID配置优化等，以提升存储设备的性能和可靠性。</li>
</ul>
</li>
<li><strong>安全和稳定性</strong>：<ul>
<li><strong>关闭不必要的服务和端口</strong>：减少系统暴露的攻击面，增强系统安全性。</li>
<li><strong>安全更新和补丁管理</strong>：定期更新系统内核和软件包，修复已知漏洞和安全问题。</li>
</ul>
</li>
<li><strong>监控和调优工具</strong>：<ul>
<li><strong>使用系统性能分析工具</strong>：如sar、top、htop、iostat等，实时监控系统的性能指标，发现瓶颈和优化机会。</li>
<li><strong>使用性能分析工具</strong>：如perf、strace、tcpdump等，用于深入分析和优化特定进程或服务的性能问题。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="4、Linux和windows有什么区别？"><a href="#4、Linux和windows有什么区别？" class="headerlink" title="4、Linux和windows有什么区别？"></a><strong>4、Linux和windows有什么区别？</strong></h4><p>windows收费，代码不开源，多用于日常办公、娱乐、游戏等。多根操作系统</p>
<p>Linux免费，代码开源，多用于服务器，具有稳定安全性的优点。单根操作系统。</p>
<h4 id="5、yum安装和编译安装有什么区别？"><a href="#5、yum安装和编译安装有什么区别？" class="headerlink" title="5、yum安装和编译安装有什么区别？"></a><strong>5、yum安装和编译安装有什么区别？</strong></h4><p>yum安装可以自动解决rpm软件依赖关系，虽然是yum安装，但是最后执行的还是rpm。</p>
<p>编译安装过程，可以设定参数按需增加功能进行安装，并可指定按装的版本和路径。</p>
<h4 id="7、你都写过什么shell脚本？"><a href="#7、你都写过什么shell脚本？" class="headerlink" title="7、你都写过什么shell脚本？"></a><strong>7、你都写过什么shell脚本？</strong></h4><p>​     提示：什么功能，都大概里面是怎么写的？</p>
<h4 id="8、linux启动顺序"><a href="#8、linux启动顺序" class="headerlink" title="8、linux启动顺序"></a>8、linux启动顺序</h4><p>计算机加电，开机自检（BIOS),MBR主引导记录，grub菜单，加载内核。</p>
<h4 id="9、在linux系统中自带的三大关键进程。"><a href="#9、在linux系统中自带的三大关键进程。" class="headerlink" title="9、在linux系统中自带的三大关键进程。"></a>9、在linux系统中自带的三大关键进程。</h4><ol>
<li><p><strong><code>init</code>（或 <code>systemd</code>）</strong>：系统初始化进程，负责启动和管理系统的所有其他进程。<code>init</code> 是所有进程的祖先，<code>systemd</code> 是许多现代 Linux 发行版中默认的初始化系统。</p>
</li>
<li><p>**<code>ksoftirqd</code>**：处理软中断的内核线程，负责处理中断请求以防止系统性能下降。</p>
</li>
<li><p>**<code>kworker</code>**：内核工作线程，用于处理内核中的延迟任务，如异步 I&#x2F;O 操作和其他后台任务</p>
<h4 id="2、简述raid0、raid1、raid5三种工作模式的工作原理及特点？"><a href="#2、简述raid0、raid1、raid5三种工作模式的工作原理及特点？" class="headerlink" title="2、简述raid0、raid1、raid5三种工作模式的工作原理及特点？"></a>2、简述raid0、raid1、raid5三种工作模式的工作原理及特点？</h4><p>raid0 —数据条带卷<br>最少需要两块磁盘，分别往每一块磁盘上写一部分数据<br>优点:<br>1.读写速度快，<br>2.磁盘利用率：100%<br>缺点:不提供数据冗余，无数据检验，不能保证数据的正确性，存在单点故障。</p>
<p>应用场景：<br>1）对数据完整性要求不高的场景，如：日志存储，个人娱乐<br>2）要求读写效率高，安全性能要求不高，如图像工作站<br>#范例：</p>
<h6 id="两块盘A和B-存数据123456-一块存123-一块存456"><a href="#两块盘A和B-存数据123456-一块存123-一块存456" class="headerlink" title="#两块盘A和B   存数据123456   一块存123 一块存456"></a>#两块盘A和B   存数据123456   一块存123 一块存456</h6><p>两个盘存相同数据<br>raid1 又叫镜像raid，通过磁盘数据镜像实现数据冗余，在成对的独立磁盘上产生互为备份的数据。<br>一般需要两块磁盘，每块磁盘上都会存储一份完整数据。其数据安全性就会较高，但是磁盘空间利用率是比较低的。</p>
<p>优点:提供数据冗余，数据双倍存储安全性高支持容错。读速度快<br>缺点:写速度不变，无数据校验。磁盘利用率不高<br>磁盘利用率：50%</p>
<p>应用场景：<br>存放重要数据，如数据存储领域<br>#范例：</p>
<h6 id="两块盘A和B-存数据123456-一块存123456-令一块也存123456"><a href="#两块盘A和B-存数据123456-一块存123456-令一块也存123456" class="headerlink" title="#两块盘A和B   存数据123456   一块存123456 令一块也存123456"></a>#两块盘A和B   存数据123456   一块存123456 令一块也存123456</h6><p>raid5：RAID5应该是目前最常见的 RAID 等级，它的校验数据分布在阵列中的所有磁盘上。RAID5的磁盘上同时存储数据和校验数据。当一个数据盘损坏时，系统可以根据其他数据块和对应的校验数据来重建损坏的数据。　</p>
<p>raid5最少需要3块磁盘。<br>优点:<br>1.可以找回丢失的数据—数据可以通过校验计算得出，<br>2.冗余磁盘–&gt;（需要4快磁盘将其中一块做热备）当某一块磁盘坏掉后，冗余磁盘会自动替换上去<br>3.有校验机制<br>4.读写速度高<br>5.磁盘利用率高<br>缺点：<br>1.磁盘越多安全性能越差</p>
<p>应用场景：安全性高，如金融、数据库、存储等。<br>#范例：</p>
<h6 id="三块盘A、B和C-存数据123456-A存123-B存456-C存校验码-当A或B当中一块坏掉，可以通过另一块中的数据和校验码算出坏掉那块中的数据。"><a href="#三块盘A、B和C-存数据123456-A存123-B存456-C存校验码-当A或B当中一块坏掉，可以通过另一块中的数据和校验码算出坏掉那块中的数据。" class="headerlink" title="#三块盘A、B和C   存数据123456   A存123 B存456 C存校验码 当A或B当中一块坏掉，可以通过另一块中的数据和校验码算出坏掉那块中的数据。"></a>#三块盘A、B和C   存数据123456   A存123 B存456 C存校验码 当A或B当中一块坏掉，可以通过另一块中的数据和校验码算出坏掉那块中的数据。</h6><p>raid6：RAID6 等级是在 RAID5 的基础上为了进一步增强数据保护而设计的一种 RAID 方式。<br>最少需要四块磁盘，两块存校验位。RAID6引入双重校验的概念，它可以保护阵列中同时出现两个磁盘失效时，阵列仍能够继续工作，不会发生数据丢失。<br>优点：<br>1.容错：允许两块磁盘同时坏掉。读写快。<br>2.良好的随机读性能<br>3.有校验机制</p>
<p>缺点：<br>1.写入速度差<br>2.成本高</p>
<p>应用场景：对数据安全级别要求比较高的企业<br>#范例：</p>
<h5 id="四块盘A、B、C和D-存数据123456-一块存123-一块存456-另外两块存校验码-两块数据盘同时丢也可以继续工作。"><a href="#四块盘A、B、C和D-存数据123456-一块存123-一块存456-另外两块存校验码-两块数据盘同时丢也可以继续工作。" class="headerlink" title="四块盘A、B、C和D   存数据123456   一块存123 一块存456 另外两块存校验码 两块数据盘同时丢也可以继续工作。"></a><strong>四块盘A、B、C和D   存数据123456   一块存123 一块存456 另外两块存校验码 两块数据盘同时丢也可以继续工作。</strong></h5><p><strong>RAID10</strong>：先做镜像再作条带–也叫混合raid<br>优点：<br>1.较高的IO性能<br>2.有数据冗余<br>3.无单点故障<br>4.安全性能高<br>缺点：成本稍高<br>应用场景：<br>特别适用于既有大量数据需要存取，同时又对数据安全性要求严格的领域，如银行、金融、商业超市、仓储库房、各种档案管理等。<br>#范例：<br>#四块盘A、B、C和D   存数据123456   A和B为一组，C和D为一组，一组存123，一组存456，组内两块存相同数据和raid1一样，这样只要不是同时坏掉两块为同一组的硬盘就不会出问题。</p>
</li>
</ol>
<p>1.你平时常用的Linux命令有哪些？</p>
<p>mkdir,touch,ls,rm -rf, useradd,userdel -r ,tar,pwd,which,cd,su,cp,mv,cat,groupadd,groupdel,</p>
<p>groupmod,tail,head。</p>
<p>2.centos7中共有几种文件类型？</p>
<p>普通文件，目录文件，设备文件，软链接文件，套接字文件，管道文件</p>
<p>3.软链接文件和硬链接文件有什么区别？<br>4.计算机网络你熟悉吗？简述一下OSI七层模型</p>
<p>物链网输会表应</p>
<p>5.应用层常见的协议有哪些？（http）</p>
<ol>
<li><strong>应用层</strong>：HTTP、FTP、SMTP、DNS 等。</li>
<li><strong>传输层</strong>：TCP、UDP。</li>
<li><strong>网络层</strong>：IP、ICMP。</li>
<li><strong>数据链路层</strong>：以太网、PPP 等。</li>
</ol>
<p>6.MAC地址属于哪一层？IP和端口呢？</p>
<p>数据链路层，网络层，传输层</p>
<p>7.TCP&#x2F;IP协议有哪些层？</p>
<p>四层，数，网，传，应</p>
<p>8.如何开机挂载一个文件？如何每次开机自动创建一个文件？</p>
<p>&#x2F;etc&#x2F;fstab          &#x2F;etc&#x2F;rc.d&#x2F;rc.local </p>
<p>9.简述一下top命令？</p>
<p>动态查看进程信息，它会显示每个进程的进程 ID (PID)、用户、CPU 占用率、内存占用率、运行时间等信息。</p>
<p>10.操作系统中进程有哪些状态？僵尸进程产生的原因是怎样的？</p>
<p>运行，睡眠，僵尸，停止，死亡，父进程未处理子进程的退出状态</p>
<p>11.如何查看服务器的CPU的核数？lscpu<br>12.有无进行过操作系统调优的方案？在LINUX中对于内核进行调优的参数在哪里？<br>7.如何查看Linux操作系统的内核版本？系统架构（arm&#x2F;x86架构）？</p>
<p>uname -r    uname -m</p>
<p>8.开机挂载的文件是在哪个位置？</p>
<p>&#x2F;etc&#x2F;rc.d&#x2F;rc.local    &#x2F;etc&#x2F;fstab</p>
<p>9.Linux常见系统目录有哪些？作用分别是？&#x2F;boot、&#x2F;proc目录的作用是？</p>
<p>&#x2F;root,&#x2F;home,&#x2F;proc,&#x2F;tmp,&#x2F;usr,&#x2F;usr&#x2F;local,&#x2F;var,&#x2F;opt,&#x2F;mnt</p>
<p>1.Mysql5.7和8.0的区别有哪些？具体点</p>
<p>MySQL 5.7版本默认编码格式为拉丁，MySQL8.0默认编码格式为utf8。<br>MySQL 8.0引入了窗口函数，而5.7不支持。且事务处理和并发性能方面有显著改进。<br>MySQL 8.0在5.7基础上引入了更强的安全性能、包括默认启动的密码验证插件、并支持更安全的连接协议（TLSv1.3）、更严格的密码策略控住等以提高数据库的安全性。<br>MySQL 8.0支持JSON数据类型，MySQL5.7不支持。<br>MySQL 8.0在对用户的权限分配方面引入了‘角色’这一概念，更加方便了对用户权限分配的管理。</p>
<p>2.日常办公时常用的SQL语句有哪些？</p>
<p>create,insert,select,delete,alter,update,</p>
<p>3.查看系统负载的shell命令？</p>
<p>uptime</p>
<p>4.通过df -Th 查看磁盘空间剩余很多，但是在touch文件的时候，无法创建（前提：磁盘是完好的，没有出现故障）。什么原因？</p>
<p>1.没有权限2.文件系统满额或配额上限3.磁盘空间未能及时更新3.文件系统损坏4.innode号上限。</p>
<p>5.执行rm -rf 删除一个文件，文件确实删除成功，但是磁盘空间没有释放。什么原因？</p>
<p>Linux中的文件都有自己的iNode号，通过这个iNode号与磁盘当中的空间是一一对应的，当我们删除一个文件时，实际上我们只是删除了iNode号，其实文件还是存放在磁盘当中的，只是我们没有了iNode号再也无法找到他了。</p>
<p>进程占用：</p>
<p>有时候，即使文件被删除了，仍然可能有某些进程或者程序仍在使用这个文件，导致操作系统无法释放该文件所占用的磁盘空间。在这种情况下，通常需要等待这些进程释放对文件的占用</p>
<p>文件系统延迟写入：</p>
<p>有些文件系统可能会有延迟写入的机制，即使文件被删除，也可能不会立即释放其占用的磁盘空间。这种情况下，文件系统可能会在适当的时机（比如系统空闲时或者需要更多空间时）才会真正释放空间</p>
<p>回收站机制：</p>
<p>如果操作系统或者文件系统有回收站机制，删除的文件可能会先进入回收站，等待一段时间后再被彻底删除以释放磁盘空间。</p>
<h4 id="1、非关系型数据库和关系型数据库这两者区别"><a href="#1、非关系型数据库和关系型数据库这两者区别" class="headerlink" title="1、非关系型数据库和关系型数据库这两者区别 ?*"></a><strong>1、</strong><em>非关系型数据库和关系型数据库这两者区别 ?</em>*</h4><p>关系型DB：有SQL语句标准，二维表结构，数据存放在磁盘当中，<br>非关系型DB：没有固定的SQL语句标准，大多数非关系DB数据存放在内存当中。</p>
<p>关系型DB：MySQL、SQL server、mariadb、pgsql、oracle<br>非关系型DB：MongoDB、Redis、memcached</p>
<h4 id="2、甲骨文数据库与mysql这两者有啥区别？"><a href="#2、甲骨文数据库与mysql这两者有啥区别？" class="headerlink" title="2、甲骨文数据库与mysql这两者有啥区别？"></a><strong>2、甲骨文数据库与mysql这两者有啥区别？</strong></h4><p>1.MySQL是开源的，免费使用。oracle是收费的。</p>
<p>2.Oracle的SQL语句更难，而MySQL的SQL语句更简单一点。</p>
<p>3.mysql是轻量级的数据库，适合中小型企业和Web应用，易于安装和管理，性能高效且成本低。oracle是重量级数据库，成本较高，适合大型企业，能够处理复杂的业务需求、大规模数据和高并发事务。</p>
<h4 id="3、常用的数据类型，char和varchar有什么区别？"><a href="#3、常用的数据类型，char和varchar有什么区别？" class="headerlink" title="3、常用的数据类型，char和varchar有什么区别？"></a><strong>3、常用的数据类型，char和varchar有什么区别？</strong></h4><p>整型，浮点型，字符串型，枚举类型，时间和日期类型</p>
<p>char表示定长字符串，长度是固定的；如果插入数据的长度小于char的固定长度时，则用空格填充；因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间。</p>
<ul>
<li><p>varchar表示可变长字符串，长度是可变的；插入的数据是多长，就按照多长来存储；varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间。</p>
</li>
<li><p>结合性能角度（char更快），节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。</p>
<h4 id="4-事务的四个特性"><a href="#4-事务的四个特性" class="headerlink" title="4.事务的四个特性"></a><strong>4.事务的四个特性</strong></h4><p>原子性：事务是不可分割的最小单位，要么全部执行，要么全都不执行。</p>
<p>一致性：当事务完成时，数据必须处于一致状态。<br>3.隔离性（isolation）：对数据进行修改的所有并发事务是彼此隔离的，这表明事务必须是独立的，它不应以任何方式依赖于或影响其他事务。<br>4.持久性（durability）：事务完成后，它对数据库的修改被永久保存，即使系统发生故障，已提交的事务修改也不会丢失。</p>
<h4 id="5、三种存储引擎的区别？"><a href="#5、三种存储引擎的区别？" class="headerlink" title="5、三种存储引擎的区别？"></a>5、三种存储引擎的区别？</h4><ol>
<li><strong>InnoDB</strong>：默认的存储引擎，支持事务、外键和行级锁，安全性高，插入查询速度不高，适用于需要高并发和数据完整性的应用。</li>
<li><strong>MyISAM</strong>：不支持事务和外键。拥有较高的插入查询速度，如果应用的数据完整性、并发性要求比较低，也可以使用。</li>
<li><strong>MEMORY</strong>（内存型引擎）：数据的处理速度快，但是安全性低，不可建立太大的表。</li>
</ol>
<p><strong>5、说一下MySQL5.7和MySQL8.0的区别？</strong></p>
<p>MySQL 5.7版本默认编码格式为拉丁，MySQL8.0默认编码格式为utf8。<br>MySQL 8.0引入了窗口函数，而5.7不支持。且事务处理和并发性能方面有显著改进。<br>MySQL 8.0在5.7基础上引入了更强的安全性能、包括默认启动的密码验证插件、并支持更安全的连接协议（TLSv1.3）、更严格的密码策略控住等以提高数据库的安全性。<br>MySQL 8.0支持JSON数据类型，MySQL5.7不支持。<br>MySQL 8.0在对用户的权限分配方面引入了‘角色’这一概念，更加方便了对用户权限分配的管理。</p>
<h4 id="7-多表查询所所用到的连接？"><a href="#7-多表查询所所用到的连接？" class="headerlink" title="7.多表查询所所用到的连接？"></a><strong>7.多表查询所所用到的连接？</strong></h4><p>等值连接，非等值连接，自连接，非自连接，内连接，外连接</p>
<h4 id="8-Mysql的约束条件都有哪些？"><a href="#8-Mysql的约束条件都有哪些？" class="headerlink" title="8.Mysql的约束条件都有哪些？"></a><em><strong>8.<em>Mysql的约束条件都有哪些？</em></strong></em></h4><ol>
<li><strong>PRIMARY KEY</strong>：主键唯一标识记录，确保列值唯一且非空。</li>
<li><strong>FOREIGN KEY</strong>：外键确保列值存在于另一表的列中，用于维护表之间的参照完整性。</li>
<li><strong>UNIQUE</strong>：唯一值，确保列中的所有值唯一，但允许空值。唯一约束</li>
<li><strong>NOT NULL</strong>：不能为空值，确保列不能包含空值。</li>
<li><strong>CHECK</strong>：检查约束，确保列中的值满足特定条件（MySQL 8.0.16及以上版本支持）。</li>
<li><strong>DEFAULT</strong>：为列指定默认值，可更改。当插入新记录时，若没有提供该列的值，则使用默认值。</li>
<li><strong>AUTO_INCREMENT</strong>		标识该字段的值自动增长（整数类型，而且为主键）</li>
</ol>
<p>这些约束条件帮助确保数据的完整性和一致性。</p>
<h4 id="9-主从复制原理"><a href="#9-主从复制原理" class="headerlink" title="9.主从复制原理"></a><strong>9.主从复制原理</strong></h4><p>实现整个主从复制，需要由slave服务器上的IO进程和Sql进程共同完成.<br>要实现主从复制，首先必须打开Master端的binary log（bin-log）功能，因为整个MySQL复制过程实际上就是Slave从Master端获取相应的二进制日志，然后再在自己slave端完全顺序的执行日志中所记录的各种操作。</p>
<p>\1. 在主服务器上把数据更改（增删改SQL语句）记录到二进制日志（Binary Log）中。</p>
<p>\2. 从服务器的I&#x2F;O线程将主服务器上的日志复制到自己的中继日志（Relay Log）中。</p>
<p>\3. 从服务器的SQL线程读取中继日志中的事件，将其执行到从数据库之上。</p>
<p><strong><strong><strong><strong>10.mysql物理备份有几种？都有什么特点</strong></strong></strong></strong></p>
<h4 id="Mysql数据备份方式有几种？有什么区别"><a href="#Mysql数据备份方式有几种？有什么区别" class="headerlink" title="Mysql数据备份方式有几种？有什么区别"></a><strong>Mysql数据备份方式有几种？有什么区别</strong></h4><p>1.物理备份：类似于cp复制</p>
<p>优点：恢复速度快。缺点：文件大</p>
<p>2.逻辑备份：只备份SQL语句</p>
<p>优点：文件小（因为全是SQL语句）。缺点：恢复速度慢（SQL语句要一句一句执行）</p>
<p>物理备份工具：xtrabackup</p>
<p>开源社区备份工具</p>
<p>开源免费,上面的免费版本(老版本有问题,备份出来的数据可能有问题)</p>
<p>逻辑备份工具：mysqldump</p>
<p>官方自带备份工具 开源免费</p>
<p>逻辑备份(速度慢)</p>
<p><strong>物理备份的主要方式</strong>：</p>
<p>**热备(hot backup)：在线备份，数据库处于运行状态，这种备份方法依赖于数据库的日志文件。对应用基本无影响(但是性能还是会有下降,所以尽量不要在主上做备份,在从库上做)</p>
<p>冷备(cold backup)：需要完全停止数据库服务来进行备份。备份过程中数据库服务完全停止，没有任何运行的数据库操作。确保备份文件的一致性和完整性。</p>
<p>温备(warm backup)：备份时候实例只读不可写，数据库锁定表格（不可写入但可读）的状态下进行的。对应用影响很大。通常加一个读锁，备份时候实例只读不可写，数据库锁定表格（不可写入但可读）的状态下进行的。</p>
<p><strong>完全备份：</strong>每次对数据进行完整的备份，即对整个数据库的备份、数据库结构和文件结构的备份。</p>
<p>优点：备份与恢复操作简单方便，恢复时一次恢复到位，恢复速度快</p>
<p>缺点：占用空间大，备份速度慢</p>
<p><strong>增量备份</strong>: 每次备份上一次备份到现在产生的新数据</p>
<p>特点：因而备份的数据量小，占用空间小，备份速度快。但恢复时，需要从上一次的完整备份起按备份时间顺序，逐个备份版本进行恢复，恢复时间长，如中间某次的备份数据损坏，将导致数据的丢失。</p>
<p><strong>差异备份</strong>：只备份跟完整备份不一样的数据。</p>
<p>特点：占用空间比增量备份大，比完整备份小，恢复时仅需要恢复第一个完整版本和最后一次的差异版本，恢复速度介于完整备份和增量备份之间。</p>
<p>每周日进行完全备份，周三进行增量备份，周六进行差异备份。</p>
<p><strong>你觉得哪种备份方式好一些，说一下原因</strong>？</p>
<p>逻辑备份</p>
<p>原因： 其备份数据库建表、建库、插入sql语句，备份文件相对较小,只备份表中的数据与结构。</p>
<h4 id="11、索引的定义以及优缺点？"><a href="#11、索引的定义以及优缺点？" class="headerlink" title="11、索引的定义以及优缺点？"></a><strong>11、索引的定义以及优缺点？</strong></h4><p>索引是一种数据结构，用于提高数据的查询效率。索引是在<code>存储引擎</code>中实现的 ，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的 <code>最大索引数</code> 和<code>最大索引长度</code>。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。</p>
<p>优点:</p>
<ul>
<li>提高数据检索的效率，降低 	<code>数据库的IO成本</code>。</li>
<li>通过创建唯一索引，可以保证数据库表中每一行 <code>数据的唯一性 </code>。</li>
<li>对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。</li>
<li>在使用分组和排序子句进行数据查询时，可以显著 <code>减少查询中分组和排序的时间 ，降低了CPU的消耗</code>。</li>
</ul>
<p> 缺点:</p>
<ul>
<li>创建索引和维护索引要耗费时间 ，并且随着数据量的增加，所耗费的时间也会增加。</li>
<li>索引需要占用磁盘空间 ，除了数据表占数据空间之外，每一个索引还要占一定的物理空间。</li>
<li>虽然索引大大提高了查询速度，同时却会降低更新表的速度 。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</li>
</ul>
</li>
</ul>
<h4 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a><strong>索引的分类</strong></h4><p>普通索引（INDEX）<br>用于加速查询，不需要唯一。可以在列上创建索引以加速查询性能，没有唯一性要求。只是用于提高查询效率。</p>
<p>唯一索引（UNIQUE）<br>限制该索引的值必须是唯一的，但允许有空(NULL)值。在一张数据表里 可以有多个唯一索引。</p>
<p>主键索引（PRIMARY KEY）<br>索引列值必须唯一，不能为NULL。每个表只能有一个主键索引，它主要用于唯一标识表中的每一行，并作为表的主标识符。</p>
<p><strong>索引失效的场景以及怎么避免索引失效？</strong></p>
<p>未使用索引的查询，范围查询中的索引失效，LIKE查询中的索引失效，数据类型不匹配，索引列上使用了函数。</p>
<p>正确设计索引，避免在索引列上使用函数，避免在<code>LIKE</code>语句中使用通配符开头，注意数据类型匹配，优化查询语句</p>
<p>员工ID主键、电话号码唯一、身份证号主键。</p>
<h4 id="2-Mysql集群中主从复制的原理是怎样的？"><a href="#2-Mysql集群中主从复制的原理是怎样的？" class="headerlink" title="2.Mysql集群中主从复制的原理是怎样的？"></a><strong>2.Mysql集群中主从复制的原理是怎样的？</strong></h4><p>实现整个主从复制，需要由slave服务器上的IO进程和Sql进程共同完成.<br>要实现主从复制，首先必须打开Master端的binary log（bin-log）功能，因为整个MySQL复制过程实际上就是Slave从Master端获取相应的二进制日志，然后再在自己slave端完全顺序的执行日志中所记录的各种操作。</p>
<p>1.在master端把数据更改记录(增删改)记录到二进制日志中，slave端的i&#x2F;o线程读取binlog日志中的内容到自己的中继日志，sql线程读取中继日志中的事件，将其执行在从数据库之上。</p>
<h4 id="2、Mysql主从复制能解决什么问题？为什么要做主从复制？"><a href="#2、Mysql主从复制能解决什么问题？为什么要做主从复制？" class="headerlink" title="2、Mysql主从复制能解决什么问题？为什么要做主从复制？"></a>2、Mysql主从复制能解决什么问题？为什么要做主从复制？</h4><ol>
<li><strong>数据备份</strong>：从服务器可以用于数据备份，确保数据在主服务器出现故障时不会丢失。</li>
<li><strong>高可用性</strong>：在主服务器出现故障时，从服务器可以快速提升为主服务器，保证服务的连续性和可用性。</li>
</ol>
<p>​    3.<strong>提高整体性能和吞吐量</strong>：通过将读请求分散到多个从服务器上进行处理，从而减轻了主服务器的负载压    力，提高数据库系统的整体性能和吞吐量。</p>
<h4 id="3、MySQL中主从同步的方式？他们有哪些区别？"><a href="#3、MySQL中主从同步的方式？他们有哪些区别？" class="headerlink" title="3、MySQL中主从同步的方式？他们有哪些区别？"></a><strong>3、MySQL中主从同步的方式？他们有哪些区别？</strong></h4><p><strong>全同步复制</strong>：主服务器将数据修改操作记录到二进制日志，并等待全部从服务器确认已接收到并应用了这些日志后才继续执行后续操作。</p>
<p>优点：数据一致性和可靠性</p>
<p>缺点：延迟大，影响主服务器性能。</p>
<p><strong>异步复制</strong>：默认模式，在此模式下，主服务器将更改发送给从服务器，但不会等待确认。这意味着主服务器可以在没有收到从服务器确认的情况下继续处理新的事务。</p>
<p>优点：及时响应，提高主服务器的性能。</p>
<p>缺点：可能存在数据传输的延迟，以及数据的丢失。</p>
<p><strong>半同步复制</strong>：在此模式下，主服务器将更改发送给从服务器，并等待至少一个从服务器确认接收到数据后才继续处理新的事务。</p>
<p>优点：可以提供更高的数据一致性和可靠性，确保至少一个从服务器与主服务器保持同步。</p>
<p>缺点：由于半同步复制需要等待从服务器的确认，因此相对于异步复制，会增加一定的延迟，可能会影响主服务器的性能。</p>
<p>性能：异步复制 &gt; 半同步复制 &gt; 全同步复制<br>数据安全性：全同步复制 &gt; 半同步复制 &gt; 异步复制</p>
<h4 id="主从复制的两种机制"><a href="#主从复制的两种机制" class="headerlink" title="主从复制的两种机制"></a><strong>主从复制的两种机制</strong></h4><p>1.binlog日志方式2.Gtid日志方式</p>
<ul>
<li><p><strong>日志机制</strong>：传统的binlog方式依赖于日志文件的管理和位置，而GTID方式则依赖于全局唯一的事务标识符。</p>
</li>
<li><p><strong>故障恢复</strong>：GTID提供了更自动化的故障恢复能力，而传统binlog方式需要手动介入。</p>
</li>
<li><p><strong>管理复杂性</strong>：GTID简化了复制和管理的复杂性，但引入了额外的系统配置要求。</p>
<h4 id="面试"><a href="#面试" class="headerlink" title="面试"></a><strong>面试</strong></h4><ol>
<li><p>如何查看MySQL主从之间的数据延迟多大？<br>答： 使用<code>SHOW SLAVE STATUS\G</code>查看<code>Seconds_Behind_Master</code>延迟时间。</p>
</li>
<li><p>如何解决主从数据没有一致的问题？<br> 答：首先，使用 SHOW SLAVE STATUS\G 命令检查从服务器的复制状态，关注以下关键字段：<br> <code>Slave_IO_Running</code> 和 <code>Slave_SQL_Running：</code>都应为 Yes。<code>Last_IO_Error </code>和 <code>Last_SQL_Error</code>：应为空。<code>Seconds_Behind_Master：</code>应尽量接近于 0。如果主从数据延迟过大，推荐主机进行备份，从机导入数据。采用GTID模式（全局事务标识符）。可以使用 pt-table-checksum 和 pt-table-sync 工具查找主库和从库的不一致数据，并恢复。</p>
</li>
</ol>
<h4 id="88-主从复制延迟大比较慢原因："><a href="#88-主从复制延迟大比较慢原因：" class="headerlink" title="88.主从复制延迟大比较慢原因："></a>88.主从复制延迟大比较慢原因：</h4><p>  主服务器配置高，从服务器的配置低。<br>  并发量大导致主服务器读的慢。从服务器写的慢<br>  网络延迟比较高<br>  从服务器的读写速度慢<br>  2.从数据库的读的延迟问题了解吗？如何解决？<br>  解决方法：<br>  半同步复制—解决数据丢失的问题<br>  并行复制—-解决从库复制延迟的问题</p>
</li>
</ul>
<h4 id="MySQL-5-7日志分类"><a href="#MySQL-5-7日志分类" class="headerlink" title="MySQL 5.7日志分类"></a><strong>MySQL 5.7日志分类</strong></h4><p>错误日志，通用查询日志，二进制日志，中继日志，回滚日志</p>
<p>二进制日志：它是一种特殊的二进制格式文件，记录了数据库更改（怎删改）操作。</p>
<p><strong>二进制日志三种格式：</strong></p>
<p>1、statement格式，binlog 记录的是执行的 SQL 语句的文本。</p>
<p>2、ROW 格式，在这种格式下，binlog 记录的是每一行数据更改的具体内容。</p>
<p>3、MIXED 格式（混合模式）：在这种格式下，binlog 可以根据具体的 SQL 语句和操作自动选择使用 STATEMENT 或 ROW 格式。</p>
<h4 id="25-MySQL如何优化？"><a href="#25-MySQL如何优化？" class="headerlink" title="25.MySQL如何优化？"></a><strong>25.MySQL如何优化？</strong></h4><p>一：调优思路：</p>
<p>1.数据库设计与规划–以后再修该很麻烦，估计数据量，使用什么存储引擎</p>
<p>2.数据的应用–怎样查询数据，sql语句的优化</p>
<p>3.mysql服务优化–内存的使用，磁盘的使用</p>
<p>4.操作系统的优化–内核，磁盘IO，内存</p>
<p>5.升级硬件设备</p>
<p>6.创建索引提升查询速度</p>
<h4 id="27-什么是读写分离？"><a href="#27-什么是读写分离？" class="headerlink" title="27.什么是读写分离？"></a><strong>27.什么是读写分离？</strong></h4><p>主库处理所有写操作（如插入、更新、删除），而从库处理读操作（如查询）。这样可以减轻主库的负担，提升系统性能和响应速度。通过这种方式，读请求可以分散到多个从库上，从而实现负载均衡和更高的可用性。</p>
<p>优点：</p>
<ol>
<li><p><strong>性能优化</strong>：将读请求和写请求分开处理，减少主库的负载，提高查询速度。</p>
</li>
<li><p><strong>负载均衡</strong>：通过将读请求分发到多个从库，分摊查询压力，减少主库的压力。</p>
</li>
<li><p><strong>高可用性：</strong>增加冗余，提高服务可用性，当一台数据库服务器宕机后可以调整另外一台从库以最快速度恢复服务</p>
<p><strong>30.Mysql的四种隔离级别</strong>*</p>
</li>
<li><p><strong>读未提交（Read Uncommitted）</strong>：最低隔离级别，允许读取尚未提交的数据。</p>
</li>
<li><p><strong>读已提交（Read Committed）</strong>：只允许读取已提交的数据，防止脏读。</p>
</li>
<li><p><strong>可重复读（Repeatable Read）</strong>：确保在一个事务内读取的数据一致，防止不可重复读，MySQL 默认的隔离级别。</p>
</li>
<li><p><strong>串行化（Serializable）</strong>：最高隔离级别，所有事务按顺序执行，防止幻读。</p>
<h4 id="脏读、不可重复读、幻读是什么？"><a href="#脏读、不可重复读、幻读是什么？" class="headerlink" title="脏读、不可重复读、幻读是什么？"></a><strong>脏读、不可重复读、幻读是什么？</strong></h4><p>脏读：a开启了一个事务并更新了数据，但是未提交，b读取了a更新的数据，但是a此时进行了事务回滚，b读到的就是脏数据<br>不可重复读：事务a多次读取同一数据，事务b在a多次读取过程中对数据做了更新并提交，导致a在多次读取数据时结果不一致。<br>幻读：管理员a将学生成绩从具体分数改为abcde等级，但是管理员b在这个时候插入了一条具体分数的记录，当管理员a修改结束后，发现还有一条数据没改过来，就像发生了幻觉一样。<br>不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除，解决不可重复读只需锁住满足条件的行，解决幻读需要进行锁表</p>
</li>
</ol>
<p>有4种</p>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th align="right">幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>是</td>
<td>是</td>
<td align="right">是</td>
</tr>
<tr>
<td>不可重复读（read-committed）</td>
<td>否</td>
<td>是</td>
<td align="right">是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>否</td>
<td>否</td>
<td align="right">是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td align="right">否</td>
</tr>
</tbody></table>
<h4 id="linux计划任务前5列"><a href="#linux计划任务前5列" class="headerlink" title="linux计划任务前5列"></a>linux计划任务前5列</h4><p>分钟小时日月周。</p>
<h4 id="2、动、静态请求的区别-面试点"><a href="#2、动、静态请求的区别-面试点" class="headerlink" title="2、动、静态请求的区别(面试点)"></a><strong>2、动、静态请求的区别(<code>面试点</code>)</strong></h4><ul>
<li><p>静态请求指的是获取预先存在并不需要额外处理的静态内容，响应速度较快。如HTML文件、CSS样式表、JavaScript脚本、图像、视频和其他媒体文件等。</p>
</li>
<li><p>动态请求指的是根据特定条件动态生成内容的请求，响应时间较长，需要服务器端进行处理和计算。</p>
<h4 id="1-http的定义以及工作原理"><a href="#1-http的定义以及工作原理" class="headerlink" title="1.http的定义以及工作原理"></a>1.http的定义以及工作原理</h4><p>HTTP（超文本传输协议）是应用层协议。它是整个数据通信的基础，基于请求&#x2F;响应模式，客户端与服务器之间通过互相发送报文来通信。</p>
<p>建立连接，发送请求，服务器响应，数据传送，释放连接。</p>
<p>无连接，无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。</p>
<p>无状态，无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。</p>
<p>缓存控制为了提高加载速度和减少带宽消耗，HTTP提供了缓存机制。</p>
<p>HTTP 是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送，客户端以及服务器指定使用适合的 MIME-type 内容类型。</p>
<h4 id="Http的请求方法："><a href="#Http的请求方法：" class="headerlink" title="Http的请求方法："></a>Http的请求方法：</h4><p>get用于获取静态页面。</p>
<p>post用于上传创建新文件（会产生新数据）。</p>
<p>put保存数据（覆盖更新文件）不会产生新数据。</p>
<p>delete请求服务器删除指定页面。</p>
<h4 id="2、nginx配置文件详解"><a href="#2、nginx配置文件详解" class="headerlink" title="2、nginx配置文件详解"></a>2、nginx配置文件详解</h4><p>全局模块，events模块，http模块(http里面包括server模块和多个location模块)。</p>
<h4 id="3-nginx与Apache服务器的区别"><a href="#3-nginx与Apache服务器的区别" class="headerlink" title="3.nginx与Apache服务器的区别"></a>3.nginx与Apache服务器的区别</h4><p>Apache是开源项目，apache功能丰富且稳定，擅长处理动态请求，适合复杂的企业级应用。采用同步多进程模型，一个连接对应一个进程，而nginx是异步的，多个连接可以对应一个进程。</p>
<p>nginx是轻量级，高并发，负载均衡服务器，擅长处理静态请求和做反向代理，比apache占用更少的资源和空间。</p>
<h4 id="4-常用的状态码以及如何解决问题"><a href="#4-常用的状态码以及如何解决问题" class="headerlink" title="4.常用的状态码以及如何解决问题"></a>4.常用的状态码以及如何解决问题</h4><p>200 访问成功</p>
<p>301 永久重定向</p>
<p>302 临时重定向</p>
<p>临时重定向返回302状态码，原本的URL地址仍然有效。永久重定向返回的状态码是301，原本的URL地址已经失效。临时重定向是暂时的，可能下次访问不再重定向，而永久重定向是永久的，会一直访问重定向后的网站资源，原来的网站资源已经失效。</p>
<p>304表示未修改，是一种缓存机制。当客户端已经拥有一个缓存的响应，并且该响应的内容在服务器端没有发生变化时，服务器可以返回304状态码，告诉客户端继续使用缓存的响应。这种方式可以减少不必要的<a target="_blank" rel="noopener" href="https://cloud.baidu.com/product/et.html">网络</a>传输，提高网页加载速度，从而提升用户体验。</p>
<p>400：服务器无法理解客户端请求（请求格式错误）</p>
<p>403  服务器理解客户端的请求，访问被拒绝（权限不足，提升权限）</p>
<p>404 找不到页面</p>
<p>网址输入错误，页面被删，没联网</p>
<p>500 服务器内部出现错误</p>
<p>检查服务器的配置</p>
<p>检查服务器的错误日志，</p>
<p>502代理服务器无法从后端服务器获取有效的响应，或者后端服务器出现了问题。</p>
<p>检查上游服务器，检查网络连接，检查网关或代理服务器的配置，查看相关服务器的日志文件，增加超时设置。</p>
<p>503 服务不可用：检查服务器负载，检查资源使用情况。</p>
<p>504 网关超时。检查服务器的响应时间，确认网络连接是否正常，检查代理或网关的超时设置。</p>
</li>
</ul>
<h4 id="5-反向代理和正向代理区别"><a href="#5-反向代理和正向代理区别" class="headerlink" title="5.反向代理和正向代理区别"></a>5.反向代理和正向代理区别</h4><h5 id="1、代理对象不同：正向代理代理的是客户端，反向代理代理的是服务器端。"><a href="#1、代理对象不同：正向代理代理的是客户端，反向代理代理的是服务器端。" class="headerlink" title="1、代理对象不同：正向代理代理的是客户端，反向代理代理的是服务器端。"></a>1、代理对象不同：正向代理代理的是客户端，反向代理代理的是服务器端。</h5><h5 id="2-安全性不同：正向代理隐藏真实客户端的IP地址和信息，反向代理服务器隐藏真实服务器的IP地址和真实信息。"><a href="#2-安全性不同：正向代理隐藏真实客户端的IP地址和信息，反向代理服务器隐藏真实服务器的IP地址和真实信息。" class="headerlink" title="2.安全性不同：正向代理隐藏真实客户端的IP地址和信息，反向代理服务器隐藏真实服务器的IP地址和真实信息。"></a>2.安全性不同：正向代理隐藏真实客户端的IP地址和信息，反向代理服务器隐藏真实服务器的IP地址和真实信息。</h5><p>3.<strong>使用场景不同</strong>：正向代理通常用于访问被限制或不可访问的内容，或者在内部网络中提供对外访问的方式。反向代理则主要用于实现负载均衡、安全策略、缓存等功能，提高网站性能和可用性。</p>
<h4 id="1、Nginx都有什么优点？"><a href="#1、Nginx都有什么优点？" class="headerlink" title="1、Nginx都有什么优点？"></a>1、Nginx都有什么优点？</h4><p>nginx是轻量级，高并发，负载均衡服务器，擅长处理静态请求和反向代理，比apache占用更少的资源和空间。高可用性，可以自动检测后端服务器的健康状况，并在故障时切换成后端其他真实的服务器。</p>
<h4 id="3、Nginx都能做什么？"><a href="#3、Nginx都能做什么？" class="headerlink" title="3、Nginx都能做什么？"></a>3、Nginx都能做什么？</h4><p>web服务器：显示网页</p>
<p>负载均衡：将请求平均分配给后端服务器</p>
<p>反向代理服务器：隐藏后端真实服务器地址，将客户端请求分发给后端服务器。</p>
<p>动静分离，防盗链，地址重定向，静态缓存，nginx日志：access_log，流量限制</p>
<p>rewrite_log,error_log。日志格式通过 <code>log_format</code> 关键字来定义。nginx访问控制。</p>
<h4 id="5、Nginx做动静分离有什么作用？如何做？"><a href="#5、Nginx做动静分离有什么作用？如何做？" class="headerlink" title="5、Nginx做动静分离有什么作用？如何做？"></a>5、Nginx做动静分离有什么作用？如何做？</h4><p>提高了系统的效率和响应速度。可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。</p>
<p>准备三台服务器，一台负载均衡服务器，两台web服务器，分别在两台web服务器中的子配置文件中的location模块利用正则表达式匹配静态资源和动态资源。在负载均衡服务器上的子配置文件中添加两个upsream模块，对应着动态地址和静态地址，使用不同的 <code>location</code> 模块处理不同的内容类型。</p>
<h4 id="6、Nginx负载均衡如何配置？和反向代理有什么区别"><a href="#6、Nginx负载均衡如何配置？和反向代理有什么区别" class="headerlink" title="6、Nginx负载均衡如何配置？和反向代理有什么区别"></a>6、Nginx负载均衡如何配置？和反向代理有什么区别</h4><p>准备三台服务器，一个代理服务器两个web服务器。分别在两个web服务器的子配置文件下的location模块下配置不同的页面文件发布路径，显示不同页面，在代理服务器上添加upsteram模块，然后在里面定义后端服务器的地址。在 <code>server</code> 块中使用 <code>proxy_pass</code> 指令将请求转发到定义的 <code>upstream</code> 组。默认情况下，Nginx 使用轮询（round-robin）策略进行负载均衡。</p>
<p>反向代理是指代理服务器将客户端的请求转发到后端的一个服务器，并将服务器的响应返回给客户端。主要关注的是代理请求和响应。</p>
<p>负载均衡是将客户端的请求通过负载均衡策略分配到多个后端服务器上，主要关注的是将请求有效地分配到多个服务器上，以优化资源利用和提升性能。</p>
<h4 id="7、负载均衡算法"><a href="#7、负载均衡算法" class="headerlink" title="7、负载均衡算法"></a>7、负载均衡算法</h4><p><code>轮询（Round Robin）</code>：这是默认的负载均衡策略。在这种策略下，每个请求会按时间顺序逐一分配到不同的后端服务器节点，确保每个节点平均处理请求。</p>
<p><code>加权轮询（Weighted Round Robin）</code>：这种策略允许根据服务器的性能为其分配权重，性能更好的服务器可以处理更多的请求。</p>
<p><code>最少连接（Least Connections）</code>：在这个策略下，Nginx会将新请求分配给当前连接数最少的服务器，这样可以保证服务器间的负载更加均衡。</p>
<p><code>IP Hash</code>：这种策略会根据客户端IP地址的哈希值来选择服务器，这样可以确保同一用户的请求总是被发送到同一台服务器，有助于实现会话保持。</p>
<p><code>URL Hash</code>：这种策略会根据请求的URL的哈希值来选择服务器，适用于需要根据URL分配请求到特定服务器的场景。</p>
<h4 id="Nginx防盗链如何做？"><a href="#Nginx防盗链如何做？" class="headerlink" title="Nginx防盗链如何做？"></a>Nginx防盗链如何做？</h4><p>两个网站 A 和 B， B网站引用了A网站上的图片，这种行为就叫做盗链。<br>防盗链，就是要防止B引用A的图片。</p>
<p>http_referer：上一个链接地址</p>
<p>准备两台机器，一台图片服务器，一台盗链服务器。</p>
<p>首先在图片服务器的主配置文件中的http模块中的日志格式中添加”$http_referer”。然后在图片服务器上的子配置文件中的location模块下添加valid_referers指令指定允许访问的网址或IP。如果不满足，则返回   $invalid referer</p>
<p> if ($invalid_referer) {<br>                   return 404;<br>                }</p>
<h4 id="8、查找顺序和优先级"><a href="#8、查找顺序和优先级" class="headerlink" title="8、查找顺序和优先级"></a>8、查找顺序和优先级</h4><p>多个location配置的情况下匹配顺序为：首先匹配 &#x3D;，其次匹配^~, 其次是按正则匹配，最后是交给 &#x2F; 通用匹配。</p>
<p>(1) &#x3D;:表示完全匹配;<br>(2) ^~:匹配URI的前缀，如果一个URI同时满足两个规则的话，匹配最长的规则;<br>(3) ~:匹配正则表达式，大小写敏感；<br>(4) ~*:匹配正则表达式，大小写不敏感；</p>
<img src="C:\Users\23568\AppData\Roaming\Typora\typora-user-images\image-20240831092146779.png" alt="image-20240831092146779" style="zoom: 80%;" />

<p>&#x3D;    表示精确匹配，优先级也是最高的<br>^~   表示url以某个常规字符串开头,理解为匹配url路径即可<br>~    表示区分大小写的正则匹配<br><del>*   表示不区分大小写的正则匹配<br>!</del>   表示区分大小写不匹配的正则<br>!~*  表示不区分大小写不匹配的正则<br>&#x2F;    通用匹配，任何请求都会匹配到</p>
<h4 id="10-nginx会话保持，会话保持的方法。"><a href="#10-nginx会话保持，会话保持的方法。" class="headerlink" title="10.nginx会话保持，会话保持的方法。"></a>10.nginx会话保持，会话保持的方法。</h4><p>会话保持是一种在<strong>负载均衡环境中维持客户端和服务器之间的交互状态的机制</strong>。</p>
<p><strong>1、<em>基于客户端IP地址的会话保持</em>***：</strong>ip_hash**：这种方法使用源地址哈希算法，确保来自同一客户端的请求总是被发送到相同的后端服务器。</p>
<h4 id="2、sticky-cookie-insert"><a href="#2、sticky-cookie-insert" class="headerlink" title="2、sticky_cookie_insert"></a>2、sticky_cookie_insert</h4><p>使用sticky_cookie_insert启用会话亲缘关系，这会导致来自同一客户端的请求被传递到一组服务器的同一台服务器。与ip_hash不同之处在于，它不是基于IP来判断客户端的，而是基于cookie来判断。因此可以避免上述ip_hash中来自同一客户端导致负载失衡的情况。(需要引入第三方模块才能实现)</p>
<p><strong><code>Cookie</code></strong> 是一种存储在用户浏览器中的小型文本文件，它可以用来记录用户信息，如登录状态、网站偏好设置等。</p>
<h4 id="3-jvm-route"><a href="#3-jvm-route" class="headerlink" title="3. jvm_route"></a>3. jvm_route</h4><p>jvm_route的原理</p>
<ol>
<li><p>一开始请求过来，没有带session信息，jvm_route就根据轮询（round robin）的方法，发到一台tomcat上面。 </p>
</li>
<li><p>tomcat添加上session 信息，并返回给客户。 </p>
</li>
<li><p>用户再次请求，jvm_route看到session中有后端服务器的名称，它就把请求转到对应的服务器上。</p>
</li>
</ol>
<p>   <strong><code>Session</code></strong> 则是在服务器端记录用户信息的一种机制。</p>
<h4 id="11、nginx异步非阻塞的工作原理"><a href="#11、nginx异步非阻塞的工作原理" class="headerlink" title="11、nginx异步非阻塞的工作原理"></a>11、nginx异步非阻塞的工作原理</h4><p>nginx启动后会有<br>1个master进程，2个work进程<br>master进程只负责监听用户的请求，但并不处理请求。work进程才处理请求。</p>
<pre><code> 异步是指当一个请求被发起后，Nginx 不会等待该请求的处理结果，而是返回去处理其他请求。当该请求处理完成后，Nginx 再将结果返回给客户端。
 非阻塞是指当一个请求被处理时，Nginx 不会一直等待该请求的 I/O 操作完成后再处理下一个请求，而是先处理其他请求，等到该请求的 I/O 操作完成后再继续处理该请求
这种设计使得 Nginx 能够高效地处理大量并发请求，保持较低的资源占用和响应延迟。
</code></pre>
<h4 id="nginx流量限制的作用："><a href="#nginx流量限制的作用：" class="headerlink" title="nginx流量限制的作用："></a>nginx流量限制的作用：</h4><p>Nginx 的流量控制功能通过限制请求速率，限制连接数，请求队列，负载均衡等策略，帮助管理员有效管理服务器资源，防止滥用，防止恶意攻击和过度资源消耗。提高服务的稳定性和性能。</p>
<h4 id="编译安装nginx注意事项："><a href="#编译安装nginx注意事项：" class="headerlink" title="编译安装nginx注意事项："></a>编译安装nginx注意事项：</h4><p>创建软连接启动nginx</p>
<p>ln  -s   &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx      &#x2F;usr&#x2F;sbin或者&#x2F;usr&#x2F;bin</p>
<p>mkdir  &#x2F;tmp&#x2F;nginx</p>
<p>启动nginx：nginx</p>
<p>停止nginx：pkill    nginx</p>
<h4 id="I-O-multiplexing【多并发】"><a href="#I-O-multiplexing【多并发】" class="headerlink" title="I&#x2F;O multiplexing【多并发】"></a>I&#x2F;O multiplexing【多并发】</h4><p>I&#x2F;O多路复用是一种高效处理多个I&#x2F;O流的技术，它允许单个线程同时管理多个I&#x2F;O流，而不是为每个流创建单独的线程。这样做可以提高服务器的性能，尤其是在需要处理高并发的情况下。类似于在同一个线程里面， 通过拨开关的方式，来同时传输多个I&#x2F;O流。“拨开关”可以理解为线程在多个I&#x2F;O流之间快速切换。</p>
<h4 id="常用服务端口号："><a href="#常用服务端口号：" class="headerlink" title="常用服务端口号："></a>常用服务端口号：</h4><ul>
<li><p><strong>HTTP</strong>: 80</p>
</li>
<li><h5 id="Tomcat-8080"><a href="#Tomcat-8080" class="headerlink" title="Tomcat 8080"></a>Tomcat 8080</h5></li>
<li><p><strong>HTTPS</strong>: 443</p>
</li>
<li><p><strong>FTP</strong>: 21</p>
</li>
<li><p><strong>SSH</strong>: 22</p>
</li>
<li><p><strong>Telnet</strong>: 23</p>
</li>
<li><p><strong>SMTP</strong>: 25</p>
</li>
<li><h5 id="DNS-53"><a href="#DNS-53" class="headerlink" title="DNS 53"></a>DNS 53</h5></li>
<li><p><strong>POP3</strong>: 110</p>
</li>
<li><p><strong>MySQL</strong>: 3306</p>
</li>
<li><p><strong>Redis</strong>: 6379</p>
</li>
<li><p><strong>MongoDB</strong>: 27017</p>
</li>
<li><p><strong>Docker</strong>: 2375 (未加密) &#x2F; 2376 (加密)</p>
</li>
<li><p><strong>Nginx</strong>: 80 (默认HTTP) &#x2F; 443 (默认HTTPS)</p>
</li>
<li><p><strong>Apache</strong>: 80 (默认HTTP) &#x2F; 443 (默认HTTPS)</p>
</li>
</ul>
<h4 id="nginx-安全调优、性能调优？"><a href="#nginx-安全调优、性能调优？" class="headerlink" title="nginx 安全调优、性能调优？"></a>nginx 安全调优、性能调优？</h4><p>1、隐藏nginx的版本信息</p>
<p>2、限制IP地址访问</p>
<p>3、启用SSL&#x2F;TLS</p>
<p>4、限制上传文件大小</p>
<p>5、限制请求速率和连接数的配置防止DDos的攻击</p>
<p>6、启用http安全头。</p>
<p>性能调优</p>
<p>文件句柄就是一个索引，限制每一个服务能够使用的文件句柄数目。</p>
<p>分为系统全局性修改，用户局部修改和进程局部性修改</p>
<p>调整工作进程数。</p>
<p>nginx限制并发连接数</p>
<h5 id=""><a href="#" class="headerlink" title=""></a><img src="C:\Users\23568\AppData\Roaming\Typora\typora-user-images\image-20240831161909862.png" alt="image-20240831161909862" style="zoom: 150%;" /></h5><p>启用nginx缓存</p>
<p>减少后端服务器负担，提高响应速度，提高用户体验感，减少网络带宽消耗。</p>
<p>启用gzip压缩。使得数据大小减小，可以提高传输效率，提高用户体验感。但是因为是在服务器端进行的压缩，所以会消耗一定的cpu资源。</p>
<h4 id="公网证书的绑定流程？"><a href="#公网证书的绑定流程？" class="headerlink" title="公网证书的绑定流程？"></a>公网证书的绑定流程？</h4><p>root指令与alias的区别？</p>
<img src="C:\Users\23568\AppData\Roaming\Typora\typora-user-images\image-20240903174114437.png" alt="image-20240903174114437" style="zoom: 80%;" />

<ul>
<li>alias 是一个目录别名的定义;</li>
<li>root 则是最上层目录的定义。</li>
</ul>
<h4 id="流量控制的步骤，以及效果？"><a href="#流量控制的步骤，以及效果？" class="headerlink" title="流量控制的步骤，以及效果？"></a>流量控制的步骤，以及效果？</h4><p>流量限制”配置两个主要的指令，<code>limit_req_zone</code>和<code>limit_req</code></p>
<p>burst参数定义在队列中的请求数量。</p>
<p>限制并发连接数</p>
<p>可以使用limit_conn_zone指令以及limit_conn执行进行配置。</p>
<p>单个IP并发连接数和整个虚拟服务器的并发连接数。</p>
<h4 id="16、Nginx如何添加模块？-如何升级）"><a href="#16、Nginx如何添加模块？-如何升级）" class="headerlink" title="16、Nginx如何添加模块？(如何升级）"></a>16、Nginx如何添加模块？(如何升级）</h4><p>1、下载所需模块的安装包并解压到nginx的安装目录下。</p>
<p>2、安装编译工具</p>
<p>3、添加原来已经有的参数和新的模块。</p>
<p>4、编译使用make，不用make  install，否则会覆盖原来的文件。</p>
<p>5、启动nginx并查看模块是否添加成功。</p>
<p>升级(平滑)：</p>
<p>1.查看现有的nginx编译参数2.上传新版本的源码包并解压到&#x2F;usr&#x2F;local,编译使用make3.备份原nginx二进制文件，复制新的nginx二进制文件到新的二进制文件源码包。4、测试新版本nginx是否正常。5、给nginx发送平滑迁移信号并查看nginx  pid6、从容关闭旧的Nginx进程7、重新读取配置文件，但不重新启动服务。8、结束工作进程，完成升级并验证是否升级成功。</p>
<h4 id="12、找出访问日志位置"><a href="#12、找出访问日志位置" class="headerlink" title="12、找出访问日志位置"></a>12、找出访问日志位置</h4><p>find     &#x2F;    -name    access.log</p>
<p>2.2grep命令过滤出当天的,每个访客的访问次数</p>
<p>cat   &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log   | grep  “02&#x2F;Sep&#x2F;2024” | awk  ‘{print   $1}’  |  sort|uniq  -c | sort   -n  -k1    |head   -n   10</p>
<p>2.3根据访问IP统计UV</p>
<p>cat   &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log   | grep  “02&#x2F;Sep&#x2F;2024” | awk  ‘{print   $1}’  |  sort|uniq  -c | </p>
<p>wc   -1</p>
<p>2.4统计访问URL统计PV</p>
<p>cat   &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log   | grep  “02&#x2F;Sep&#x2F;2024” | awk  ‘{print   $1}’  |  sort|uniq  -c | sort   -n  -k1    |head   -n   10</p>
<p>2.5统计访问URL统计PV</p>
<p>cat   &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log   | grep  “02&#x2F;Sep&#x2F;2024” | awk ‘{print $7}’ access.log|wc -l</p>
<p>2.6查询访问最频繁的URL</p>
<p>cat   &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log   | grep  “02&#x2F;Sep&#x2F;2024”|awk ‘{print $1}’ access.log|sort | uniq -c |sort -n -k 1 -r|more</p>
<p>2.7查询访问最频繁的前10的IP</p>
<p>cat   &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log   | grep  “02&#x2F;Sep&#x2F;2024”|awk ‘{print $1}’ access.log|sort | uniq -c |sort -n -k 1 -r|head -n 10</p>
<p>2.8查询今天下午3:00-4:00，有多少PV？</p>
<p>grep ‘[03&#x2F;Oct&#x2F;2024:15:’ &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log | wc -l</p>
<p>http访问的原理？</p>
<p>建立连接，发送请求，服务器响应，数据传送，释放连接。</p>
<p>http与https的区别？</p>
<p>https添加了ssl和tls的协议，确保数据传输的安全性和完整性。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/07/%E9%9D%A2%E8%AF%95%E9%A2%98%E8%B0%B7/%E9%9D%A2%E8%AF%95%E9%A2%98%E8%B0%B7/" data-id="cm0s47kq900008svy0bggbfh5" data-title="面试题" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/10/hello-world/" class="article-date">
  <time class="dt-published" datetime="2024-07-10T12:15:14.859Z" itemprop="datePublished">2024-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/10/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/10/hello-world/" data-id="clyft205r0000q8vy4hvv7p4n" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-管道与重定向" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/03/11/%E7%AE%A1%E9%81%93%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/" class="article-date">
  <time class="dt-published" datetime="2024-03-10T16:00:00.000Z" itemprop="datePublished">2024-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>title: 面试题<br>date: 2024-09-08 15:38:00<br>tags: [Linux]<br>cover: <a target="_blank" rel="noopener" href="https://guboyan666.github.io/2024/09/07/%E7%AE%A1%E9%81%93%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/6.png">https://guboyan666.github.io/2024/09/07/管道与重定向/6.png</a></p>
<p>管道与重定向</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只有在开水里，茶叶才能展开生命浓郁的香气.</span><br></pre></td></tr></table></figure>

<h1 id="千-锋-云-计-算-学-院"><a href="#千-锋-云-计-算-学-院" class="headerlink" title="千 锋 云 计 算 学 院"></a>千 锋 云 计 算 学 院</h1><h3 id="一、重定向"><a href="#一、重定向" class="headerlink" title="一、重定向"></a>一、重定向</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标准输入、标准正确输出、标准错误输出</span><br></pre></td></tr></table></figure>

<p>​          <img src="/assets/1.png" alt="assets/1.png"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进程在运行的过程中根据需要会打开多个文件，每打开一个文件会有一个数字标识。这个标识叫文件描述符。</span><br><span class="line">进程使用文件描述符来管理打开的文件（FD----file descriptors）.</span><br><span class="line">文件描述符：每打开一个程序都会有文件描述</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0，标准输入(键盘)</span><br><span class="line">1,标准输出</span><br><span class="line">2,标准错误，</span><br><span class="line">3+,进程在执行过程中打开的其他文件。  </span><br><span class="line">&amp;:表示正确错误混合输出</span><br></pre></td></tr></table></figure>

<h3 id="二、输出重定向-覆盖，追加"><a href="#二、输出重定向-覆盖，追加" class="headerlink" title="二、输出重定向 (覆盖，追加)"></a><strong>二、输出重定向 (覆盖，追加)</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">  ----覆盖</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;  ----追加</span></span><br><span class="line">正确输出： 1&gt; 1&gt;&gt; 等价于 &gt; &gt;&gt;</span><br><span class="line">错误输出： 2&gt; 2&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>2.1. 案例1：输出重定向（覆盖）</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@qfedu.com ~]# date 1&gt; date.txt  #正确输出--覆盖</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意：如果 &gt; 前面什么都不加默认为1，标准正确输出。</span></span><br></pre></td></tr></table></figure>

<p><img src="/assets/image-20191107205931650.png" alt="image-20191107205931650"></p>
<p><strong>2.2.案例2：输出重定向（追加）</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@qfedu.com ~]# date &gt;&gt; date.txt #正确输出--追加</span><br></pre></td></tr></table></figure>

<p><img src="/assets/image-20191107210044263.png" alt="image-20191107210044263"></p>
<p><strong>2.3. 案例3：错误输出重定向</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@qfedu.com ~]# ls /home/  /aaaaaaaaa &gt;list.txt</span><br><span class="line">ls: cannot access /aaaaaaaaa: No such file or directory</span><br><span class="line">[root@qfedu.com ~]# ls /home/  /aaaaaaaaa &gt;list.txt 2&gt;error.txt #重定向到不同的位置</span><br><span class="line">[root@qfedu.com ~]# cat error.txt </span><br><span class="line">ls: cannot access /aaaaaaaaa: No such file or directory</span><br></pre></td></tr></table></figure>



<p><strong>2.4.正确和错误都输入到相同位置</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@qfedu.com ~]# ls /home/  /aaaaaaaaa &amp;&gt;list.txt  #混合输出到相同文件</span><br></pre></td></tr></table></figure>

<p><strong>2.5.重定向到空设备&#x2F;dev&#x2F;null</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@qfedu.com ~]# ls /home/  /aaaaaaaaa &gt;list.txt 2&gt;/dev/null #空设备，将错误的输出丢掉</span><br><span class="line">[root@qfedu.com ~]# ls /home/  /aaaaaaaaa &amp;&gt;/dev/null #空设备，将正确与错误的输出丢掉</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo会将输入的内容送往标准输出（打印）</span><br><span class="line">echo 内容 &gt;&gt; 文件名或脚本里面</span><br></pre></td></tr></table></figure>

<h3 id="三、输入重定向"><a href="#三、输入重定向" class="headerlink" title="三、输入重定向 &lt;"></a>三、输入重定向 &lt;</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标准输入： &lt;   等价 0&lt;</span><br></pre></td></tr></table></figure>

<p><strong>例子</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">默认情况下，cat 命令会接受标准输入设备（键盘）的输入，并显示到控制台，但如果用文件代替键盘作为输入设备，那么该命令会以指定的文件作为输入设备，并将文件中的内容读取并显示到控制台。</span><br><span class="line"></span><br><span class="line">[root@qfedu.com ~]# cat /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">...</span><br><span class="line">[root@qfedu.com ~]# cat &lt; /etc/passwd  #输入重定向</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">...</span><br><span class="line">虽然执行结果相同，但第一行代表是以键盘作为输入设备，而第二行代码是以 /etc/passwd 文件作为输入设备</span><br><span class="line">注意：将/etc/passwd作为cat的输入，读出/etc/passwd的内容</span><br></pre></td></tr></table></figure>

<h6 id="通过输入重定向创建文件"><a href="#通过输入重定向创建文件" class="headerlink" title="通过输入重定向创建文件"></a>通过输入重定向创建文件</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（cat &gt; file &lt;&lt; EOF ）是用来创建文件或者在脚本中使用，并向文件中输入信息输入的任何东西会被写入文件中，EOF命令结束。</span><br><span class="line"></span><br><span class="line">语法：cat &gt;&gt; file5 &lt;&lt;EOF  #可以写到脚本或者文件里面</span><br><span class="line">EOF:开始和结束的标记。</span><br><span class="line">成对使用</span><br><span class="line">结尾的另一个必须定格写。</span><br></pre></td></tr></table></figure>

<p><strong>实战案例一：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@qfedu.com ~]# cat &gt;file4 &lt;&lt;EOF</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">111</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">222</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">333</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">444</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">EOF</span></span><br><span class="line">[root@qfedu.com ~]# cat file4 </span><br><span class="line">111</span><br><span class="line">222</span><br><span class="line">333</span><br><span class="line">444</span><br></pre></td></tr></table></figure>

<p><strong>实战案例二</strong></p>
<p>利用重定向建立多行的文件  脚本创建多行文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@qfedu.com ~]# vim create_file.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">cat &gt;file200.txt &lt;&lt;EOF</span><br><span class="line">111</span><br><span class="line">222</span><br><span class="line">333</span><br><span class="line">yyy</span><br><span class="line">ccc</span><br><span class="line">EOF</span><br><span class="line">[root@qfedu.com ~]# chmod +x create_file.sh </span><br><span class="line">[root@qfedu.com ~]# ./create_file.sh </span><br><span class="line">[root@qfedu.com ~]# cat file200.txt </span><br><span class="line">111</span><br><span class="line">222</span><br><span class="line">333</span><br><span class="line">yyy</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure>

<h3 id="四、管道"><a href="#四、管道" class="headerlink" title="四、管道 |"></a>四、管道 |</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用法：command1 | command2 |command3 |...</span><br></pre></td></tr></table></figure>

<p><img src="/assets/image-20200725153028330.png" alt="image-20200725153028330"></p>
<p><strong>实战案例一</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@qfedu.com ~]# ls /etc  |grep &#x27;sys&#x27;  #查询目录内符合要求的文件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>实战案例二</strong></p>
<p>将&#x2F;etc&#x2F;passwd中的用户按UID大小排序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@qfedu.com ~]# sort -t&quot;:&quot; -k3 -n /etc/passwd  #以: 分隔，将第三列按字数升序</span><br><span class="line">[root@qfedu.com ~]# sort -t&quot;:&quot; -k3 -n /etc/passwd -r #以: 分隔，将第三列按字数降序</span><br><span class="line">[root@qfedu.com ~]# sort -t&quot;:&quot; -k3 -n /etc/passwd |head #以: 分隔，将第三列按字数升序看前十行</span><br><span class="line">[root@qfedu.com ~]# sort -t&quot;:&quot; -k3 -n /etc/passwd |tail #以: 分隔，将第三列按字数升序看后十行</span><br><span class="line">参数详解：</span><br><span class="line">sort 排序，默认升序</span><br><span class="line">-t 指定分隔符</span><br><span class="line">-k 指定列</span><br><span class="line">-n 按数值</span><br><span class="line">-r 降序</span><br><span class="line">head 默认输出前十行</span><br><span class="line">tail 默认输出后十行</span><br></pre></td></tr></table></figure>

<h3 id="五、参数传递：xargs"><a href="#五、参数传递：xargs" class="headerlink" title="五、参数传递：xargs"></a>五、参数传递：xargs</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对：ls cp rm  管道不能执行。所以通过xargs。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">语法:</span><br><span class="line">cat a.txt | xargs  -i cp &#123;&#125; /目录  </span><br><span class="line">&#123;&#125;:前面传过来的内容</span><br><span class="line">-i ：为了让大括号生效</span><br><span class="line">目录时  -r</span><br><span class="line">解释：前面传过来的东西交给大括号</span><br><span class="line"></span><br><span class="line">cat file.txt |xargs ls -l          </span><br><span class="line">前面是目录或者目录的路径。  ls - l  后面可以不加大括号，直接执行。</span><br></pre></td></tr></table></figure>

<p><strong>实战案例一</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@qfedu.com ~]# touch /home/file&#123;1..5&#125;</span><br><span class="line">[root@qfedu.com ~]# vim files.txt</span><br><span class="line">/home/file1</span><br><span class="line">/home/file2</span><br><span class="line">/home/file3 </span><br><span class="line">/home/file4</span><br><span class="line">/home/file5</span><br><span class="line">[root@qfedu.com ~]# cat files.txt |ls -l #不加xargs传参，看输出结果</span><br><span class="line">[root@qfedu.com ~]# cat files.txt |rm -rvf  #不加xargs传参，看输出结果</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@qfedu.com ~]# cat files.txt |xargs ls -l</span><br><span class="line">-rw-r--rwx. 1 root root 12 Nov  7 21:57 /home/file1</span><br><span class="line">-rw-r--r--. 1 root root  0 Nov  7 21:57 /home/file2</span><br><span class="line">-rw-r--r--. 1 root root  0 Nov  7 21:57 /home/file3</span><br><span class="line">-rw-r--r--. 1 root root  0 Nov  7 21:57 /home/file4</span><br><span class="line">-rw-r--r--. 1 root root  0 Nov  7 21:57 /home/file5</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@qfedu.com ~]# cat files.txt |xargs rm -rvf</span><br><span class="line">removed ‘/home/file1’</span><br><span class="line">removed ‘/home/file2’</span><br><span class="line">removed ‘/home/file3’</span><br><span class="line">removed ‘/home/file4’</span><br><span class="line">removed ‘/home/file5’</span><br></pre></td></tr></table></figure>

<p><strong>实战案例二</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@qfedu.com ~]# touch /home/file&#123;1..5&#125;</span><br><span class="line">[root@qfedu.com ~]# # cat files.txt | xargs -i cp -rvf &#123;&#125; /tmp/</span><br><span class="line">‘/home/file1’ -&gt; ‘/tmp/file1’</span><br><span class="line">‘/home/file2’ -&gt; ‘/tmp/file2’</span><br><span class="line">‘/home/file3’ -&gt; ‘/tmp/file3’</span><br><span class="line">‘/home/file4’ -&gt; ‘/tmp/file4’</span><br><span class="line">‘/home/file5’ -&gt; ‘/tmp/file5’</span><br></pre></td></tr></table></figure>

<p><strong>作业</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.cat /2.txt 将它的结果混合输出到/opt/file.txt</span><br><span class="line">2.怎么判断一个账户是否存在？？</span><br><span class="line">3.将22覆盖到a.txt文件中</span><br><span class="line">4.&gt;与&gt;&gt;区别是什么</span><br><span class="line">5.将cat /home/b.txt中将正确的输出重定向到a.txt中将错误的输出重定向到c.txt</span><br><span class="line">6.请将vsftpd的进程杀掉，他的IPD为11223</span><br><span class="line">7.请描述一下kill与pkill的区别</span><br><span class="line">8.请描述一下什么是nice值</span><br><span class="line">9.如何删除当前目录下以.log结尾的文件？</span><br><span class="line">10.打印当前工作目录的Linux命令是？</span><br><span class="line">11.如何查看在后台运行的程序？</span><br><span class="line">12.如何将后台运行的程序调出之前台运行？</span><br><span class="line">13.2&gt;与&amp;&gt;是什么意思？</span><br><span class="line">14.请用输入重定向将123456写入a.txt文件中。</span><br><span class="line">15.动态查看进程的命令你知道哪几个？</span><br></pre></td></tr></table></figure>

<h6 id="扩展–阅读"><a href="#扩展–阅读" class="headerlink" title="扩展–阅读"></a>扩展–阅读</h6><p><strong>什么是CC攻击？</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">攻击者借助代理服务器生成指向受害主机的合法请求，实现DDOS和伪装就叫：CC(ChallengeCollapsar)。</span><br><span class="line">CC主要是用来攻击页面的。大家都有这样的经历，就是在访问论坛时，如果这个论坛比较大，访问的人比较多，打开页面的速度会比较慢，</span><br><span class="line">访问的人越多，论坛的页面越多，数据库压力就越大，被访问的频率也越高，占用的系统资源也就相当可观。</span><br></pre></td></tr></table></figure>

<p><strong>如何防御CC攻击</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.开启防火墙，过滤掉访问次数多的IP地址</span><br><span class="line">2.拒绝代理服务器访问你服务器</span><br><span class="line">怎么拒绝代理服务器访问呢？</span><br><span class="line">代理服务器有固定的IP地址，将这些IP地址都加到防火墙下，全部drop掉</span><br></pre></td></tr></table></figure>

<p><strong>CC攻击危害是什么？</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大量的流量不断冲击你的服务器，会让你的服务器负载及压力越来越大，直到服务器崩溃宕机</span><br></pre></td></tr></table></figure>

<p><strong>6.什么是DOS攻击</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DoS是Denial of Service的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法</span><br><span class="line">提供正常的服务。最常见的DoS攻击有计算机网络带宽攻击和连通性攻击。</span><br></pre></td></tr></table></figure>

<h1 id="千-锋-云-计-算-学-院-1"><a href="#千-锋-云-计-算-学-院-1" class="headerlink" title="千 锋 云 计 算 学 院"></a>千 锋 云 计 算 学 院</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/03/11/%E7%AE%A1%E9%81%93%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/" data-id="cm0t98ztl0001w0vy31dj4hiq" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-走进网络世界/走进网络世界" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/27/%E8%B5%B0%E8%BF%9B%E7%BD%91%E7%BB%9C%E4%B8%96%E7%95%8C/%E8%B5%B0%E8%BF%9B%E7%BD%91%E7%BB%9C%E4%B8%96%E7%95%8C/" class="article-date">
  <time class="dt-published" datetime="2024-02-26T16:00:00.000Z" itemprop="datePublished">2024-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="走进网络"><a href="#走进网络" class="headerlink" title="走进网络"></a>走进网络</h1><h1 id="千-锋-云-计-算-学-院"><a href="#千-锋-云-计-算-学-院" class="headerlink" title="千 锋 云 计 算 学 院"></a>千 锋 云 计 算 学 院</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">长风破浪会有时，直挂云帆济沧海。</span><br></pre></td></tr></table></figure>

<h3 id="1-认识计算机"><a href="#1-认识计算机" class="headerlink" title="1.认识计算机"></a>1.认识计算机</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.计算机网络是由计算机和通讯构成的，网络研究的是“通信”。 ------1946 世界上第一台计算机</span><br><span class="line">2.终端：只有输入和输出功能，没有计算和处理功能。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3.数据：一串数字（二进制数），通常指文字、语音等。</span><br><span class="line">4.通信：将源所产生的数据传递到目的的过程。</span><br><span class="line">5.网络：由两台或者两台以上计算机组成，能够进行信息共享的环境。</span><br><span class="line">6.网络的构成：（计算机、手机、pad、服务器……）、传输介质（网线、光纤、数据线……）、网络设备（交换机、路由器、防火墙）</span><br></pre></td></tr></table></figure>

<h3 id="2-传输介质"><a href="#2-传输介质" class="headerlink" title="2.传输介质"></a>2.传输介质</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">传输介质包括电缆、双绞线和光纤等。</span><br><span class="line"></span><br><span class="line">1.双绞线：有效传输长度100M</span><br><span class="line">线序:</span><br><span class="line">标准568A：绿白绿，橙白蓝，蓝白橙，棕白棕。</span><br><span class="line">标准568B：橙白橙，绿白蓝，蓝白绿，棕白棕。</span><br><span class="line"></span><br><span class="line">2.光纤</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3.单位换算</span><br><span class="line">带宽：带宽是以比特为单位的 而我们常看到的下载速度显示的几KB是以字节为单位</span><br><span class="line">KB--千字节</span><br><span class="line">B---拜特--byte（字节）</span><br><span class="line">b---比特--bit （位）---&gt; 1比特=1位</span><br><span class="line">1字节(byte)=8比特(bit)</span><br><span class="line">1KB=1024字节(byte)</span><br></pre></td></tr></table></figure>

<h3 id="3-客户端与服务器端的概念"><a href="#3-客户端与服务器端的概念" class="headerlink" title="3.客户端与服务器端的概念"></a>3.客户端与服务器端的概念</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端: 即表示可以介入互联网的个人终端设备, 比如个人PC机、个人Mac电脑, 操作系统为Windows.</span><br><span class="line">服务端: 即代表在互联网中提供给用户服务的设备, 比如淘宝网、京东网、阿里云等网站或平台.</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">名词介绍</span><br><span class="line">设备:</span><br><span class="line">二层--数据链路层: 交换机(也有三层交换机)</span><br><span class="line">三层--网络层: 路由器</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">交换机：</span><br><span class="line">简单的说，交换机就是用来组建一个局域网使用的。交换机的作用是放到路由器后端，来扩展路由器接口不够用而使</span><br><span class="line">用的。比如说，有20台电脑需要用网络，而路由器最多的只有8个口，只能接7台电脑，怎么办呢，这就需要交换机</span><br><span class="line">来扩展网络接口实现了。</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">交换机基本都是24口起步，企业的都是48口起步</span></span><br></pre></td></tr></table></figure>

<p><img src="/assets/image-20191202162151899.png" alt="image-20191202162151899"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">路由器：</span><br><span class="line">路由器的工作原理是怎么样的呢？路由器有个路由表，会自己学习、生成、维护路由表。</span><br><span class="line">1，主机A准备发数据给主机B。</span><br><span class="line">2，A将B的IP地址连同数据一起，以数据包形式发送给路由器R1。</span><br><span class="line">3，路由器R1收到数据包后，先从数据中读取到B的IP地址，然后根据路径表计算发往B的最优路径。</span><br><span class="line">4，比如路径为：R1-&gt;R2-&gt;R5-&gt;B；并将数据包发往路由器R2。</span><br><span class="line">5，路由器2重复路由器1的工作，并将数据包转发给路由器5。</span><br><span class="line">6，路由器5同样取出目的地址，发现目的地址就在自己的网段上，于是将该数据包直接交给主机B。</span><br><span class="line">7，主机B收到主机A的信息，一次完整的通信宣告结束。</span><br></pre></td></tr></table></figure>

<p><img src="/assets/image-20191202163248233.png" alt="image-20191202163248233"></p>
<p><img src="/assets/image-20191202163332065.png" alt="image-20191202163332065"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网关：网络的出口（路由器的ip地址）</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DNS：域名服务器</span><br><span class="line">端口号：1-65535 http---80 https--443 telnet--23 ftp--21、20 ssh--22 mysql--3306 php--9000 tomcat---8080</span><br></pre></td></tr></table></figure>

<h3 id="4-OSI七层模型"><a href="#4-OSI七层模型" class="headerlink" title="4.OSI七层模型"></a>4.OSI七层模型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1981年 IOS (国际化标准组织）提出了---&gt;OSI 七层模型</span><br><span class="line">OSI七层: 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</span><br></pre></td></tr></table></figure>

<p><strong>特点: 下层只和上层有来往关系, 不可跨层传输</strong></p>
<p><img src="/assets/image-20191123115326223.png" alt="image-20191123115326223"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">应用层：针对应用约定的标准 HTTP（超文本传输协议） Telnet（远程协议）</span><br><span class="line">表示层：约束数据格式，负责格式转化，加密。解密。</span><br><span class="line">会话层：建立、维护、管理（解除）会话。数据的传输通道。</span><br><span class="line">传输层：约定数据采用何种方式进行传递</span><br><span class="line">TCP协议：传输控制协议，实现数据的可靠传输</span><br><span class="line">UDP协议：用户数据报协议，实现数据的快递传输，不可靠</span><br><span class="line">网络层：提供逻辑地址（IP地址，用于在网络中标识每一台设备，作用于网络间的通信，提供路由和选路）</span><br><span class="line">数据链路层：提供MAC（物理）地址，每个MAC地址写在网卡上</span><br><span class="line">物理层：约定接口类型，传输速度</span><br></pre></td></tr></table></figure>

<h3 id="5-数据包的传输过程"><a href="#5-数据包的传输过程" class="headerlink" title="5.数据包的传输过程"></a>5.<strong>数据包的传输过程</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OSI七层: 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</span><br></pre></td></tr></table></figure>

<p><img src="/assets/image-20191123113642685.png" alt="image-20191123113642685"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ARP协议： 如何获取mac地址：先发送一个ARP请求，发送给每一个主机，这成为广播，给予ARP层回应以单播的形式返回</span><br><span class="line">案例：</span><br><span class="line">小明：我是小明，谁是小红，我的mac地址是sdfsdfs213</span><br><span class="line">arp发送广播：每个人开始拆包，其他人：是找小红的，不是找我的，不管它</span><br><span class="line">小红：拆开一看，是找我的，回复：小明，我是小红，我的mac地址是dfgert213</span><br><span class="line">进行数据传输</span><br></pre></td></tr></table></figure>

<h3 id="6-TCP-IP-传输控制协议"><a href="#6-TCP-IP-传输控制协议" class="headerlink" title="6.TCP&#x2F;IP:传输控制协议"></a>6.TCP&#x2F;IP:传输控制协议</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TCP\IP模型</span><br><span class="line">应用层：将OSI上三层融合，用于产生需要传递的数据</span><br><span class="line">传输层</span><br><span class="line">网络层</span><br><span class="line">链路层(网络接口层)：将OSI下两层融合</span><br></pre></td></tr></table></figure>

<p><img src="/assets/image-20191123114100628.png" alt="image-20191123114100628"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当通过http发起一个请求时，应用层、传输层、网络层和链路层的相关协议依次对该请求进行包装并携带对应的首部，最终在链路层生成以太网数据包，以太网数据包通过物理介质传输给对方主机，对方接收到数据包以后，然后再一层一层采用对应的协议进行拆包，最后把应用层数据交给应用程序处理。</span><br><span class="line"></span><br><span class="line">网络通信就好比送快递，商品外面的一层层包裹就是各种协议，协议包含了商品信息、收货地址、收件人、联系方式等，然后还需要配送车、配送站、快递员，商品才能最终到达用户手中。</span><br><span class="line"></span><br><span class="line">一般情况下，快递是不能直达的，需要先转发到对应的配送站，然后由配送站再进行派件。</span><br><span class="line"></span><br><span class="line">配送车就是物理介质，配送站就是网关， 快递员就是路由器，收货地址就是IP地址，联系方式就是MAC地址。 </span><br><span class="line"></span><br><span class="line">快递员负责把包裹转发到各个配送站，配送站根据收获地址里的省市区，确认是否需要继续转发到其他配送站，当包裹到达了目标配送站以后，配送站再根据联系方式找到收件人进行送件。</span><br></pre></td></tr></table></figure>

<h3 id="7-HTTP协议简介"><a href="#7-HTTP协议简介" class="headerlink" title="7.HTTP协议简介"></a>7.HTTP协议简介</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">超文本传输协议 (HTTP-Hypertext transfer protocol) 是一种详细规定了浏览器和万维网服务器之间互相通 信的规则，通过因特网传送万维网文档的数据传送协议，于1990年提出. </span><br><span class="line">• 是一个基于TCP/IP通信协议来传递数据，（HTML文件，图片等） </span><br><span class="line">HTTP是一个属于应用层的协议</span><br></pre></td></tr></table></figure>

<p>**HTTP协议的主要特点： **</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.支持客户/服务器模式 （浏览器/服务器模式） 及c/s模式</span><br><span class="line">2.简单快速：</span><br><span class="line">客户向服务器请求服务时，只需传送请求和路径。通信速度很快。</span><br><span class="line">3.灵活：HTTP允许传输任意类型的数据对象。（文件，视频，会议）</span><br><span class="line">4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</span><br></pre></td></tr></table></figure>

<p><strong>常见状态代码：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">200 OK #客户端请求成功</span><br><span class="line">403 Forbidden #服务器收到请求，但是拒绝提供服务,没有权限</span><br><span class="line">404 Not Found #请求资源不存在，输入了错误的URL，没有找到，路径不对</span><br><span class="line">比如：HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>

<h3 id="UDP协议介绍"><a href="#UDP协议介绍" class="headerlink" title="UDP协议介绍"></a>UDP协议介绍</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">UDP协议简介</span><br><span class="line">UDP是一个无连接的简单的面向数据报的传输层协议。</span><br><span class="line"></span><br><span class="line">UDP的特性:</span><br><span class="line">1.面向无连接：不用先与对方建立连接，不握手。因此传输速度很快。</span><br><span class="line">2.不可靠的：没有确认机制，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。</span><br><span class="line">3.UDP传输数据时有大小限制，每个被传输的数据报必须限定在64KB之内</span><br><span class="line">因为它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</span><br><span class="line"> </span><br><span class="line">udp一般用于</span><br><span class="line">1. 即时通信:qq聊天 对数据准确性和丢包要求比较低，但速度必须快</span><br><span class="line">2. 在线视频:速度一定要快，保证视频连续，但是偶尔花了一个图像帧，人们还是能接受的</span><br><span class="line">3. 网络语音电话:语音数据包一般比较小，需要高速发送，偶尔断音或串音也没问题</span><br></pre></td></tr></table></figure>

<p><strong>物理地址：mac地址，全球唯一，mac由6段16进制数组成，每段有2个16进制数</strong></p>
<p><strong>ARP</strong> </p>
<p><strong>arp协议作用</strong> (地址解析协议)         </p>
<blockquote>
<p>ARP地址解析协议用于将网络地址（IP地址32位）转化为物理地址（MAC地址48位）。ARP协议是属于”数据链路层 or 网络层”的协议，在以太网中的数据帧从一个主机到达网内的另一台主机是根据48位的以太网地址（硬件地址）来确定接口的，而不是根据32位的IP地址。内核（如驱动）必须知道目的端的硬件地址才能发送数据</p>
</blockquote>
<p><strong>ICMP</strong></p>
<blockquote>
<p>ICMP是（Internet Control Message Protocol）Internet控制报文协议。它是TCP&#x2F;IP协议族的一个子协议，用于在IP主机、路v由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。</p>
</blockquote>
<p><strong>作业</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">了解机房的环境，温度，上架过程，以及去机房相关流程</span><br></pre></td></tr></table></figure>

<h1 id="千-锋-云-计-算-学-院-1"><a href="#千-锋-云-计-算-学-院-1" class="headerlink" title="千 锋 云 计 算 学 院"></a>千 锋 云 计 算 学 院</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/02/27/%E8%B5%B0%E8%BF%9B%E7%BD%91%E7%BB%9C%E4%B8%96%E7%95%8C/%E8%B5%B0%E8%BF%9B%E7%BD%91%E7%BB%9C%E4%B8%96%E7%95%8C/" data-id="cm0t9qagb000010vychv74q0m" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux/" style="font-size: 10px;">Linux</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/09/08/%E7%AE%A1%E9%81%93%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91-1/">管道与重定向</a>
          </li>
        
          <li>
            <a href="/2024/09/07/%E9%9D%A2%E8%AF%95%E9%A2%98%E8%B0%B7/%E9%9D%A2%E8%AF%95%E9%A2%98%E8%B0%B7/">面试题</a>
          </li>
        
          <li>
            <a href="/2024/07/10/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2024/03/11/%E7%AE%A1%E9%81%93%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/02/27/%E8%B5%B0%E8%BF%9B%E7%BD%91%E7%BB%9C%E4%B8%96%E7%95%8C/%E8%B5%B0%E8%BF%9B%E7%BD%91%E7%BB%9C%E4%B8%96%E7%95%8C/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>